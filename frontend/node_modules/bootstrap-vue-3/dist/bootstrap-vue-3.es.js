var tl = Object.defineProperty;
var al = (e, t, a) => t in e ? tl(e, t, { enumerable: !0, configurable: !0, writable: !0, value: a }) : e[t] = a;
var ce = (e, t, a) => (al(e, typeof t != "symbol" ? t + "" : t, a), a);
import { computed as u, Comment as ll, reactive as Ae, inject as Ie, onMounted as me, onBeforeUnmount as At, ref as M, toRef as o, onActivated as xt, watch as ie, nextTick as Fe, defineComponent as x, provide as je, openBlock as c, createElementBlock as b, unref as s, normalizeClass as F, renderSlot as B, createBlock as z, resolveDynamicComponent as K, withCtx as E, createElementVNode as q, withDirectives as Xe, createTextVNode as Z, toDisplayString as D, createVNode as Se, Fragment as oe, createCommentVNode as R, normalizeStyle as qe, useSlots as Le, mergeProps as U, getCurrentInstance as nl, renderList as ve, resolveComponent as It, normalizeProps as Ce, h as Q, Transition as ol, onUnmounted as sl, isReactive as il, useAttrs as aa, withModifiers as nt, isRef as Ke, vModelCheckbox as rl, vModelRadio as ul, vModelSelect as dl, guardReactiveProps as xe, Teleport as cl, createSlots as fl } from "vue";
import { Collapse as vl, Popover as ht, Tooltip as vt, Alert as bl, Carousel as ml, Dropdown as gl, Modal as pl, Offcanvas as hl } from "bootstrap";
const yl = (e) => u(
  () => e.value === "center" ? "justify-content-center" : e.value === "end" ? "justify-content-end" : "justify-content-start"
), ot = (e, t) => Object.keys(e).filter((a) => !t.includes(a)).reduce((a, l) => ({ ...a, [l]: e[l] }), {}), Ne = () => ({ enumerable: !0, configurable: !1, writable: !1 }), tt = (e) => Array.isArray(e) ? e.map((t) => tt(t)) : e instanceof Date ? new Date(e.getTime()) : e && typeof e == "object" ? Object.getOwnPropertyNames(e).reduce((t, a) => {
  var l;
  return Object.defineProperty(t, a, (l = Object.getOwnPropertyDescriptor(e, a)) != null ? l : {}), t[a] = tt(e[a]), t;
}, Object.create(Object.getPrototypeOf(e))) : e, yt = (e) => new Promise((t) => t(tt(e)));
class st {
  constructor(t, a = {}) {
    ce(this, "cancelable", !0);
    ce(this, "componentId", null);
    ce(this, "defaultPrevented", !1);
    ce(this, "nativeEvent", null);
    ce(this, "preventDefault");
    ce(this, "relatedTarget", null);
    ce(this, "target", null);
    ce(this, "eventType", "");
    ce(this, "vueTarget", null);
    if (!t)
      throw new TypeError(
        `Failed to construct '${this.constructor.name}'. 1 argument required, ${arguments.length} given.`
      );
    Object.assign(this, st.Defaults, this.constructor.Defaults, a, { eventType: t }), Object.defineProperties(this, {
      type: Ne(),
      cancelable: Ne(),
      nativeEvent: Ne(),
      target: Ne(),
      relatedTarget: Ne(),
      vueTarget: Ne(),
      componentId: Ne()
    });
    let l = !1;
    this.preventDefault = function() {
      this.cancelable && (l = !0);
    }, Object.defineProperty(this, "defaultPrevented", {
      enumerable: !0,
      get() {
        return l;
      }
    });
  }
  static get Defaults() {
    return {
      eventType: "",
      cancelable: !0,
      nativeEvent: null,
      target: null,
      relatedTarget: null,
      vueTarget: null,
      componentId: null
    };
  }
}
const Bl = (e) => e !== null && typeof e == "object", la = (e) => /^[0-9]*\.?[0-9]+$/.test(String(e)), na = (e) => Object.prototype.toString.call(e) === "[object Object]", oa = /_/g, sa = /([a-z])([A-Z])/g, $l = /(\s|^)(\w)/g, kl = /(\s|^)(\w)/, Ye = /\s+/, Sl = /^#/, Cl = /^#[A-Za-z]+[\w\-:.]*$/, Bt = (e, t = 2) => typeof e == "string" ? e : e == null ? "" : Array.isArray(e) || na(e) && e.toString === Object.prototype.toString ? JSON.stringify(e, null, t) : String(e), Ht = (e) => e.replace(oa, " ").replace(sa, (t, a, l) => `${a} ${l}`).replace(kl, (t, a, l) => a + l.toUpperCase()), Dt = (e) => e.replace(oa, " ").replace(sa, (t, a, l) => `${a} ${l}`).replace($l, (t, a, l) => a + l.toUpperCase()), Tl = (e) => {
  const t = e.trim();
  return t.charAt(0).toUpperCase() + t.slice(1);
}, bt = (e) => `\\${e}`, wl = (e) => {
  e = Bt(e);
  const { length: t } = e, a = e.charCodeAt(0);
  return e.split("").reduce((l, n, r) => {
    const d = e.charCodeAt(r);
    return d === 0 ? `${l}\uFFFD` : d === 127 || d >= 1 && d <= 31 || r === 0 && d >= 48 && d <= 57 || r === 1 && d >= 48 && d <= 57 && a === 45 ? l + bt(`${d.toString(16)} `) : r === 0 && d === 45 && t === 1 ? l + bt(n) : d >= 128 || d === 45 || d === 95 || d >= 48 && d <= 57 || d >= 65 && d <= 90 || d >= 97 && d <= 122 ? l + n : l + bt(n);
  }, "");
}, ia = typeof window < "u", ra = typeof document < "u", Vl = typeof navigator < "u", _l = ia && ra && Vl, ua = ra ? document : {}, Oe = (e) => !!(e && e.nodeType === Node.ELEMENT_NODE), Al = (e) => Oe(e) ? e.getBoundingClientRect() : null, xl = (e = []) => {
  const { activeElement: t } = document;
  return t && !e.some((a) => a === t) ? t : null;
}, Il = (e) => Oe(e) && e === xl(), Fl = (e, t = {}) => {
  try {
    e.focus(t);
  } catch (a) {
    console.error(a);
  }
  return Il(e);
}, Ol = (e, t) => t && Oe(e) && e.getAttribute(t) || null, zl = (e) => {
  if (Ol(e, "display") === "none")
    return !1;
  const t = Al(e);
  return !!(t && t.height > 0 && t.width > 0);
}, qt = (e, t) => !e || e(t).filter((a) => a.type !== ll).length < 1, Pl = (e, t) => (Oe(t) ? t : ua).querySelector(e) || null, Nl = (e, t) => Array.from([(Oe(t) ? t : ua).querySelectorAll(e)]), da = (e, t) => t && Oe(e) ? e.getAttribute(t) : null, Ll = (e, t, a) => {
  t && Oe(e) && e.setAttribute(t, a);
}, El = (e, t) => {
  t && Oe(e) && e.removeAttribute(t);
}, Hl = (e, t) => Bt(e).toLowerCase() === Bt(t).toLowerCase(), Je = ia ? window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || ((e) => setTimeout(e, 16)) : (e) => setTimeout(e, 0), it = (e, t, a) => t.concat(["sm", "md", "lg", "xl", "xxl"]).reduce((l, n) => (l[e ? `${e}${n.charAt(0).toUpperCase() + n.slice(1)}` : n] = a, l), /* @__PURE__ */ Object.create(null)), ca = (e, t, a, l = a) => Object.keys(t).reduce((n, r) => (e[r] && n.push(
  [l, r.replace(a, ""), e[r]].filter((d) => d && typeof d != "boolean").join("-").toLowerCase()
), n), []), _e = (e = "") => `__BVID__${Math.random().toString().slice(2, 8)}___BV_${e}__`, rt = (e, t) => e === !0 || e === "true" || e === "" ? "true" : e === "grammar" || e === "spelling" ? e : t === !1 ? "true" : e === !1 || e === "false" ? "false" : void 0, mt = (e) => !!e && typeof e == "object" && e.constructor === Object, $t = (e, t, a = !0) => {
  const l = e instanceof Date && typeof e.getMonth == "function" ? new Date(e.getTime()) : Object.assign({}, e);
  return mt(e) && mt(t) && Object.keys(t).forEach((n) => {
    mt(t[n]) ? n in e ? l[n] = $t(e[n], t[n], a) : Object.assign(l, { [n]: t[n] }) : Array.isArray(t[n]) && Array.isArray(e[n]) ? Object.assign(l, {
      [n]: a ? e[n].concat(
        t[n].filter((r) => !e[n].includes(r))
      ) : t[n]
    }) : Object.assign(l, { [n]: t[n] });
  }), l;
}, $e = (e, t = {}, a = {}) => {
  const l = [e];
  let n;
  for (let r = 0; r < l.length && !n; r++) {
    const d = l[r];
    n = a[d];
  }
  return n && typeof n == "function" ? n(t) : n;
}, Re = (e, t = NaN) => Number.isInteger(e) ? e : t, Dl = (e, t = NaN) => {
  const a = parseInt(e, 10);
  return isNaN(a) ? t : a;
}, Ft = (e, t = NaN) => {
  const a = parseFloat(e.toString());
  return isNaN(a) ? t : a;
}, Rt = (e, t) => t + (e ? Tl(e) : ""), fa = (e, t) => (Array.isArray(t) ? t.slice() : Object.keys(t)).reduce(
  (a, l) => (a[l] = e[l], a),
  {}
), ql = (e) => typeof e == "boolean" ? e : e === "" ? !0 : e === "true", Ue = (e) => !!(e.href || e.to);
function i(e) {
  return u(() => e.value === void 0 ? void 0 : ql(e.value));
}
const va = Symbol(), ba = {
  items: Ae([]),
  reset() {
    this.items = Ae([]);
  }
}, Rl = (e) => {
  e.provide(va, ba);
}, jl = () => {
  const e = Ie(va);
  return e || ba;
}, fe = (e, t, a) => {
  me(() => {
    var l;
    (l = e == null ? void 0 : e.value) == null || l.addEventListener(t, a);
  }), At(() => {
    var l;
    (l = e == null ? void 0 : e.value) == null || l.removeEventListener(t, a);
  });
}, ma = (e) => u(() => ({
  "form-check": !e.plain && !e.button,
  "form-check-inline": e.inline,
  "form-switch": e.switch,
  [`form-control-${e.size}`]: e.size && e.size !== "md"
})), ga = (e) => u(() => ({
  "form-check-input": !e.plain && !e.button,
  "is-valid": e.state === !0,
  "is-invalid": e.state === !1,
  "btn-check": e.button
})), pa = (e) => u(() => ({
  "form-check-label": !e.plain && !e.button,
  btn: e.button,
  [`btn-${e.buttonVariant}`]: e.button,
  [`btn-${e.size}`]: e.button && e.size && e.size !== "md"
})), ha = (e) => u(() => {
  var t;
  return {
    "aria-invalid": rt(e.ariaInvalid, e.state),
    "aria-required": ((t = e.required) == null ? void 0 : t.toString()) === "true" ? "true" : null
  };
}), ya = (e) => u(() => ({
  "was-validated": e.validated,
  "btn-group": e.buttons && !e.stacked,
  "btn-group-vertical": e.stacked,
  [`btn-group-${e.size}`]: e.size
})), at = (e, t, a) => e.reduce(
  (l, n) => n.type.toString() === "Symbol(Fragment)" ? l.concat(n.children) : l.concat([n]),
  []
).filter((l) => (l.type.__name || l.type.name) === t).map((l) => {
  const n = (l.children.default ? l.children.default() : []).find(
    (r) => r.type.toString() === "Symbol(Text)"
  );
  return {
    props: {
      disabled: a,
      ...l.props
    },
    text: n ? n.children : ""
  };
}), Ba = (e, t) => typeof e == "string" ? {
  props: {
    value: e,
    disabled: t.disabled
  },
  text: e
} : {
  props: {
    value: e[t.valueField],
    disabled: t.disabled || e[t.disabledField],
    ...e.props
  },
  text: e[t.textField],
  html: e[t.htmlField]
}, $a = (e, t, a, l, n) => ({
  ...e,
  props: {
    "button-variant": a.buttonVariant,
    form: a.form,
    name: l.value,
    id: `${n.value}_option_${t}`,
    button: a.buttons,
    state: a.state,
    plain: a.plain,
    size: a.size,
    inline: !a.stacked,
    required: a.required,
    ...e.props
  }
}), ge = (e, t) => u(() => (e == null ? void 0 : e.value) || _e(t)), ka = {
  ariaInvalid: {
    type: [Boolean, String],
    default: void 0
  },
  autocomplete: { type: String, required: !1 },
  autofocus: { type: Boolean, default: !1 },
  disabled: { type: Boolean, default: !1 },
  form: { type: String, required: !1 },
  formatter: { type: Function, required: !1 },
  id: { type: String, required: !1 },
  lazy: { type: Boolean, default: !1 },
  lazyFormatter: { type: Boolean, default: !1 },
  list: { type: String, required: !1 },
  modelValue: { type: [String, Number], default: "" },
  name: { type: String, required: !1 },
  number: { type: Boolean, default: !1 },
  placeholder: { type: String, required: !1 },
  plaintext: { type: Boolean, default: !1 },
  readonly: { type: Boolean, default: !1 },
  required: { type: Boolean, default: !1 },
  size: { type: String, required: !1 },
  state: { type: Boolean, default: null },
  trim: { type: Boolean, default: !1 }
}, Sa = (e, t) => {
  const a = M();
  let l = null, n = !0;
  const r = ge(o(e, "id"), "input"), d = (h, k, $ = !1) => (h = String(h), typeof e.formatter == "function" && (!e.lazyFormatter || $) ? (n = !1, e.formatter(h, k)) : h), f = (h) => e.trim ? h.trim() : e.number ? parseFloat(h) : h, v = () => {
    Fe(() => {
      var h;
      e.autofocus && ((h = a.value) == null || h.focus());
    });
  };
  me(v), me(() => {
    a.value && (a.value.value = e.modelValue);
  }), xt(v);
  const g = u(
    () => {
      var h;
      return rt(e.ariaInvalid, (h = e.state) != null ? h : void 0);
    }
  ), m = (h) => {
    const { value: k } = h.target, $ = d(k, h);
    if ($ === !1 || h.defaultPrevented) {
      h.preventDefault();
      return;
    }
    if (e.lazy)
      return;
    const O = f($);
    e.modelValue !== O && (l = k, t("update:modelValue", O)), t("input", $);
  }, y = (h) => {
    const { value: k } = h.target, $ = d(k, h);
    if ($ === !1 || h.defaultPrevented) {
      h.preventDefault();
      return;
    }
    if (!e.lazy)
      return;
    l = k, t("update:modelValue", $);
    const O = f($);
    e.modelValue !== O && t("change", $);
  }, p = (h) => {
    if (t("blur", h), !e.lazy && !e.lazyFormatter)
      return;
    const { value: k } = h.target, $ = d(k, h, !0);
    l = k, t("update:modelValue", $);
  }, T = () => {
    var h;
    e.disabled || (h = a.value) == null || h.focus();
  }, V = () => {
    var h;
    e.disabled || (h = a.value) == null || h.blur();
  };
  return ie(
    () => e.modelValue,
    (h) => {
      !a.value || (a.value.value = l && n ? l : h, l = null, n = !0);
    }
  ), {
    input: a,
    computedId: r,
    computedAriaInvalid: g,
    onInput: m,
    onChange: y,
    onBlur: p,
    focus: T,
    blur: V
  };
}, De = (e, t) => {
  if (!e)
    return e;
  if (t in e)
    return e[t];
  const a = t.split(".");
  return De(e[a[0]], a.splice(1).join("."));
}, gt = (e, t = null, a, l) => {
  if (Object.prototype.toString.call(e) === "[object Object]") {
    const n = De(e, l.valueField), r = De(e, l.textField), d = De(e, l.htmlField), f = De(e, l.disabledField), v = e[l.optionsField] || null;
    return v !== null ? {
      label: String(De(e, l.labelField) || r),
      options: Ot(v, a, l)
    } : {
      value: typeof n > "u" ? t || r : n,
      text: String(typeof r > "u" ? t : r),
      html: d,
      disabled: Boolean(f)
    };
  }
  return {
    value: t || e,
    text: String(e),
    disabled: !1
  };
}, Ot = (e, t, a) => Array.isArray(e) ? e.map((l) => gt(l, null, t, a)) : Object.prototype.toString.call(e) === "[object Object]" ? (console.warn(
  `[BootstrapVue warn]: ${t} - Setting prop "options" to an object is deprecated. Use the array format instead.`
), Object.keys(e).map((l) => {
  const n = e[l];
  switch (typeof n) {
    case "object":
      return gt(n.text, String(n.value), t, a);
    default:
      return gt(n, String(l), t, a);
  }
})) : [], Ml = ["id"], Ca = Symbol(), Gl = /* @__PURE__ */ x({
  __name: "BAccordion",
  props: {
    flush: { default: !1 },
    free: { default: !1 },
    id: { default: void 0 }
  },
  setup(e) {
    const t = e, a = ge(o(t, "id"), "accordion"), l = i(o(t, "flush")), n = i(o(t, "free")), r = u(() => ({
      "accordion-flush": l.value
    }));
    return n.value || je(Ca, a.value.toString()), (d, f) => (c(), b("div", {
      id: s(a),
      class: F(["accordion", s(r)])
    }, [
      B(d.$slots, "default")
    ], 10, Ml));
  }
}), Ta = /* @__PURE__ */ x({
  __name: "BCollapse",
  props: {
    accordion: null,
    id: { default: _e() },
    modelValue: { default: !1 },
    tag: { default: "div" },
    toggle: { default: !1 },
    visible: { default: !1 },
    isNav: { default: !1 }
  },
  emits: ["update:modelValue", "show", "shown", "hide", "hidden"],
  setup(e, { emit: t }) {
    const a = e, l = i(o(a, "modelValue")), n = i(o(a, "toggle")), r = i(o(a, "visible")), d = i(o(a, "isNav")), f = M(), v = M(), g = u(() => ({
      show: l.value,
      "navbar-collapse": d.value
    })), m = () => t("update:modelValue", !1);
    return fe(f, "show.bs.collapse", () => {
      t("show"), t("update:modelValue", !0);
    }), fe(f, "hide.bs.collapse", () => {
      t("hide"), t("update:modelValue", !1);
    }), fe(f, "shown.bs.collapse", () => t("shown")), fe(f, "hidden.bs.collapse", () => t("hidden")), me(() => {
      var y;
      v.value = new vl(f.value, {
        parent: a.accordion ? `#${a.accordion}` : void 0,
        toggle: n.value
      }), (r.value || l.value) && (t("update:modelValue", !0), (y = v.value) == null || y.show());
    }), ie(
      () => l.value,
      (y) => {
        var p, T;
        y ? (p = v.value) == null || p.show() : (T = v.value) == null || T.hide();
      }
    ), ie(
      () => r.value,
      (y) => {
        var p, T;
        y ? (t("update:modelValue", !!y), (p = v.value) == null || p.show()) : (t("update:modelValue", !!y), (T = v.value) == null || T.hide());
      }
    ), (y, p) => (c(), z(K(e.tag), {
      id: e.id,
      ref_key: "element",
      ref: f,
      class: F(["collapse", s(g)]),
      "data-bs-parent": e.accordion || null,
      "is-nav": s(d)
    }, {
      default: E(() => [
        B(y.$slots, "default", {
          visible: s(l),
          close: m
        })
      ]),
      _: 3
    }, 8, ["id", "class", "data-bs-parent", "is-nav"]));
  }
}), Ul = {
  mounted(e, t) {
    let a = t.value;
    Object.keys(t.modifiers).length > 0 && ([a] = Object.keys(t.modifiers)), e.setAttribute("data-bs-toggle", "modal"), e.setAttribute("data-bs-target", `#${a}`);
  }
}, Wl = {
  mounted(e, t) {
    let a = "right";
    const l = [];
    t.modifiers.left ? a = "left" : t.modifiers.right ? a = "right" : t.modifiers.bottom ? a = "bottom" : t.modifiers.top && (a = "top"), t.modifiers.manual ? l.push("manual") : (t.modifiers.click && l.push("click"), t.modifiers.hover && l.push("hover"), t.modifiers.focus && l.push("focus")), e.setAttribute("data-bs-toggle", "popover"), new ht(e, {
      trigger: l.length === 0 ? "click" : l.join(" "),
      placement: a,
      content: t.value
    });
  },
  unmounted(e) {
    const t = ht.getInstance(e);
    t == null || t.dispose();
  }
}, Xl = (e) => {
  if (e.classList.contains("offcanvas"))
    return "offcanvas";
  if (e.classList.contains("collapse"))
    return "collapse";
  throw Error("Couldn't resolve toggle type");
}, Kl = (e, t) => {
  const { modifiers: a, arg: l, value: n } = e, r = Object.keys(a || {}), d = typeof n == "string" ? n.split(Ye) : n;
  if (Hl(t.tagName, "a")) {
    const f = da(t, "href") || "";
    Cl.test(f) && r.push(f.replace(Sl, ""));
  }
  return Array.prototype.concat.apply([], [l, d]).forEach((f) => typeof f == "string" && r.push(f)), r.filter((f, v, g) => f && g.indexOf(f) === v);
}, zt = {
  mounted(e, t) {
    const a = Kl(t, e), l = [];
    let n = "data-bs-target";
    e.tagName === "a" && (n = "href");
    for (let r = 0; r < a.length; r++) {
      const d = a[r], f = document.getElementById(d);
      f && (e.setAttribute("data-bs-toggle", Xl(f)), l.push(`#${d}`));
    }
    l.length > 0 && e.setAttribute(n, l.join(","));
  }
}, Jl = (e, t) => {
  if (t != null && t.trigger)
    return t.trigger;
  if (e.manual)
    return "manual";
  const a = [];
  return e.click && a.push("click"), e.hover && a.push("hover"), e.focus && a.push("focus"), a.length > 0 ? a.join(" ") : "hover focus";
}, Yl = (e, t) => t != null && t.placement ? t.placement : e.left ? "left" : e.right ? "right" : e.bottom ? "bottom" : "top", Zl = (e) => e != null && e.delay ? e.delay : 0, jt = (e) => typeof e == "object" ? e == null ? void 0 : e.title : e, Ql = {
  beforeMount(e, t) {
    e.setAttribute("data-bs-toggle", "tooltip"), e.getAttribute("title") || e.setAttribute("title", jt(t.value).toString());
    const a = /<("[^"]*"|'[^']*'|[^'">])*>/.test(e.title), l = Jl(t.modifiers, t.value), n = Yl(t.modifiers, t.value), r = Zl(t.value), d = e.getAttribute("title");
    new vt(e, {
      trigger: l,
      placement: n,
      delay: r,
      html: a
    }), d && e.setAttribute("data-bs-original-title", d);
  },
  updated(e, t) {
    e.getAttribute("title") || e.setAttribute("title", jt(t.value).toString());
    const a = e.getAttribute("title"), l = e.getAttribute("data-bs-original-title"), n = vt.getInstance(e);
    e.removeAttribute("title"), a && a !== l && (n == null || n.setContent({ ".tooltip-inner": a }), e.setAttribute("data-bs-original-title", a));
  },
  unmounted(e) {
    const t = vt.getInstance(e);
    t == null || t.dispose();
  }
}, Ze = /* @__PURE__ */ new Map(), wa = (e) => {
  if (Ze.has(e)) {
    const t = Ze.get(e);
    t && t.stop && t.stop(), Ze.delete(e);
  }
}, Mt = (e, t) => {
  const a = {
    margin: "0px",
    once: !1,
    callback: t.value
  };
  Object.keys(t.modifiers).forEach((n) => {
    Number.isInteger(n) ? a.margin = `${n}px` : n.toLowerCase() === "once" && (a.once = !0);
  }), wa(e);
  const l = new tn(
    e,
    a.margin,
    a.once,
    a.callback,
    t.instance
  );
  Ze.set(e, l);
}, en = {
  beforeMount(e, t) {
    Mt(e, t);
  },
  updated(e, t) {
    Mt(e, t);
  },
  unmounted(e) {
    wa(e);
  }
};
class tn {
  constructor(t, a, l, n, r) {
    ce(this, "element");
    ce(this, "margin");
    ce(this, "once");
    ce(this, "callback");
    ce(this, "instance");
    ce(this, "observer");
    ce(this, "doneOnce");
    ce(this, "visible");
    this.element = t, this.margin = a, this.once = l, this.callback = n, this.instance = r, this.createObserver();
  }
  createObserver() {
    if (this.observer && this.stop(), !(this.doneOnce || typeof this.callback != "function")) {
      try {
        this.observer = new IntersectionObserver(this.handler.bind(this), {
          root: null,
          rootMargin: this.margin,
          threshold: 0
        });
      } catch {
        console.error("Intersection Observer not supported"), this.doneOnce = !0, this.observer = void 0, this.callback(null);
        return;
      }
      this.instance.$nextTick(() => {
        this.observer && this.observer.observe(this.element);
      });
    }
  }
  handler(t) {
    const [a] = t, l = Boolean(a.isIntersecting || a.intersectionRatio > 0);
    l !== this.visible && (this.visible = l, this.callback(l), this.once && this.visible && (this.doneOnce = !0, this.stop()));
  }
  stop() {
    this.observer && this.observer.disconnect(), this.observer = null;
  }
}
const an = {
  mounted(e, t) {
    t.value !== !1 && e.focus();
  }
}, ln = {
  BModal: Ul,
  BPopover: Wl,
  BToggle: zt,
  BTooltip: Ql,
  BVisible: en,
  focus: an
}, nn = { class: "accordion-item" }, on = ["id"], sn = ["aria-expanded", "aria-controls"], rn = { class: "accordion-body" }, un = /* @__PURE__ */ x({
  __name: "BAccordionItem",
  props: {
    id: null,
    title: null,
    visible: { default: !1 }
  },
  setup(e) {
    const t = e, a = i(o(t, "visible")), l = ge(o(t, "id"), "accordion_item"), n = Ie(Ca, "");
    return (r, d) => (c(), b("div", nn, [
      q("h2", {
        id: `${s(l)}heading`,
        class: "accordion-header"
      }, [
        Xe((c(), b("button", {
          class: F(["accordion-button", { collapsed: !s(a) }]),
          type: "button",
          "aria-expanded": s(a) ? "true" : "false",
          "aria-controls": s(l)
        }, [
          B(r.$slots, "title", {}, () => [
            Z(D(e.title), 1)
          ])
        ], 10, sn)), [
          [s(zt), void 0, s(l)]
        ])
      ], 8, on),
      Se(Ta, {
        id: s(l),
        class: "accordion-collapse",
        visible: s(a),
        accordion: s(n),
        "aria-labelledby": `heading${s(l)}`
      }, {
        default: E(() => [
          q("div", rn, [
            B(r.$slots, "default")
          ])
        ]),
        _: 3
      }, 8, ["id", "visible", "accordion", "aria-labelledby"])
    ]));
  }
}), dn = ["type", "disabled", "aria-label"], Me = /* @__PURE__ */ x({
  __name: "BCloseButton",
  props: {
    disabled: { default: !1 },
    white: { default: !1 },
    ariaLabel: { default: "Close" },
    type: { default: "button" }
  },
  setup(e) {
    const t = e, a = i(o(t, "disabled")), l = i(o(t, "white")), n = u(() => ({
      "btn-close-white": l.value
    }));
    return (r, d) => (c(), b("button", {
      type: e.type,
      class: F(["btn-close", s(n)]),
      disabled: s(a),
      "aria-label": e.ariaLabel
    }, null, 10, dn));
  }
}), cn = /* @__PURE__ */ x({
  __name: "BAlert",
  props: {
    dismissLabel: { default: "Close" },
    dismissible: { default: !1 },
    fade: { default: !1 },
    modelValue: { type: [Boolean, Number], default: !1 },
    show: { default: !1 },
    variant: { default: "info" }
  },
  emits: ["dismissed", "dismiss-count-down", "update:modelValue"],
  setup(e, { emit: t }) {
    const a = e, l = i(o(a, "dismissible"));
    i(o(a, "fade"));
    const n = i(o(a, "show")), r = M(), d = M(), f = u(() => ({
      [`alert-${a.variant}`]: !!a.variant,
      show: !!a.modelValue,
      "alert-dismissible": l.value,
      fade: !!a.modelValue
    }));
    let v;
    const g = (k) => {
      if (typeof k == "boolean")
        return 0;
      const $ = Re(k, 0);
      return $ > 0 ? $ : 0;
    }, m = () => {
      v !== void 0 && (clearTimeout(v), v = void 0);
    }, y = M(g(a.modelValue)), p = u(() => !!a.modelValue || n.value);
    At(() => {
      var k;
      m(), (k = d.value) == null || k.dispose(), d.value = void 0;
    });
    const T = u(() => a.modelValue === !0 ? !0 : a.modelValue === !1 || Re(a.modelValue, 0) < 1 ? !1 : !!a.modelValue), V = () => {
      y.value = g(a.modelValue), (T.value || n.value) && !d.value && (d.value = new bl(r.value));
    }, h = () => {
      typeof a.modelValue == "boolean" ? t("update:modelValue", !1) : t("update:modelValue", 0), t("dismissed");
    };
    return ie(() => a.modelValue, V), ie(() => n.value, V), ie(y, (k) => {
      m(), typeof a.modelValue != "boolean" && (t("dismiss-count-down", k), k === 0 && a.modelValue > 0 && t("dismissed"), a.modelValue !== k && t("update:modelValue", k), k > 0 && (v = setTimeout(() => {
        y.value--;
      }, 1e3)));
    }), (k, $) => s(p) ? (c(), b("div", {
      key: 0,
      ref_key: "element",
      ref: r,
      class: F(["alert", s(f)]),
      role: "alert"
    }, [
      B(k.$slots, "default"),
      s(l) ? (c(), b(oe, { key: 0 }, [
        k.$slots.dismissible ? (c(), b("button", {
          key: 0,
          type: "button",
          "data-bs-dismiss": "alert",
          onClick: h
        }, [
          B(k.$slots, "dismissible")
        ])) : (c(), z(Me, {
          key: 1,
          "aria-label": e.dismissLabel,
          "data-bs-dismiss": "alert",
          onClick: h
        }, null, 8, ["aria-label"]))
      ], 64)) : R("", !0)
    ], 2)) : R("", !0);
  }
}), Va = Symbol(), fn = /* @__PURE__ */ x({
  __name: "BAvatarGroup",
  props: {
    overlap: { default: 0.3 },
    rounded: { type: [Boolean, String], default: !1 },
    size: null,
    square: { default: !1 },
    tag: { default: "div" },
    variant: null
  },
  setup(e) {
    const t = e, a = i(o(t, "square")), l = u(() => kt(t.size)), n = (f) => typeof f == "string" && la(f) ? Ft(f, 0) : f || 0, r = u(
      () => Math.min(Math.max(n(t.overlap), 0), 1) / 2
    ), d = u(() => {
      const f = l.value ? `calc(${l.value} * ${r.value})` : null;
      return f ? { paddingLeft: f, paddingRight: f } : {};
    });
    return je(Va, {
      overlapScale: r,
      size: t.size,
      square: a.value,
      rounded: t.rounded,
      variant: t.variant
    }), (f, v) => (c(), z(K(e.tag), {
      class: "b-avatar-group",
      role: "group"
    }, {
      default: E(() => [
        q("div", {
          class: "b-avatar-group-inner",
          style: qe(s(d))
        }, [
          B(f.$slots, "default")
        ], 4)
      ]),
      _: 3
    }));
  }
}), vn = {
  key: 0,
  class: "b-avatar-custom"
}, bn = {
  key: 1,
  class: "b-avatar-img"
}, mn = ["src", "alt"], kt = (e) => {
  const t = typeof e == "string" && la(e) ? Ft(e, 0) : e;
  return typeof t == "number" ? `${t}px` : t || null;
}, gn = /* @__PURE__ */ x({
  __name: "BAvatar",
  props: {
    alt: { default: "avatar" },
    ariaLabel: null,
    badge: { type: [Boolean, String], default: !1 },
    badgeLeft: { default: !1 },
    badgeOffset: null,
    badgeTop: { default: !1 },
    badgeVariant: { default: "primary" },
    button: { default: !1 },
    buttonType: { default: "button" },
    disabled: { default: !1 },
    icon: null,
    rounded: { type: [Boolean, String], default: "circle" },
    size: null,
    square: { default: !1 },
    src: null,
    text: null,
    textVariant: { default: void 0 },
    variant: { default: "secondary" }
  },
  emits: ["click", "img-error"],
  setup(e, { emit: t }) {
    const a = e, l = i(o(a, "badgeLeft")), n = i(o(a, "badgeTop")), r = i(o(a, "button")), d = i(o(a, "disabled")), f = i(o(a, "square")), v = Le(), g = ["sm", null, "lg"], m = 0.4, y = m * 0.7, p = Ie(Va, null), T = (ee) => {
      const Y = ee;
      return Y === "light" || Y === "warning" ? "dark" : "light";
    }, V = u(() => !qt(v.default)), h = u(() => !qt(v.badge)), k = u(
      () => a.badge || a.badge === "" || h.value
    ), $ = u(
      () => p != null && p.size ? p.size : kt(a.size)
    ), O = u(
      () => p != null && p.variant ? p.variant : a.variant
    ), N = u(
      () => p != null && p.rounded ? p.rounded : a.rounded
    ), w = u(() => ({
      "aria-label": a.ariaLabel || null,
      disabled: d.value || null
    })), C = u(() => ({
      [`bg-${a.badgeVariant}`]: !!a.badgeVariant
    })), _ = u(() => a.badge === !0 ? "" : a.badge), W = u(() => `text-${T(a.badgeVariant)}`), I = u(() => ({
      [`b-avatar-${a.size}`]: !!a.size && g.indexOf(kt(a.size)) !== -1,
      [`bg-${O.value}`]: !!O.value,
      badge: !r.value && O.value && V.value,
      rounded: N.value === "" || N.value === !0,
      ["rounded-circle"]: !f.value && N.value === "circle",
      ["rounded-0"]: f.value || N.value === "0",
      ["rounded-1"]: !f.value && N.value === "sm",
      ["rounded-3"]: !f.value && N.value === "lg",
      ["rounded-top"]: !f.value && N.value === "top",
      ["rounded-bottom"]: !f.value && N.value === "bottom",
      ["rounded-start"]: !f.value && N.value === "left",
      ["rounded-end"]: !f.value && N.value === "right",
      btn: r.value,
      [`btn-${O.value}`]: r.value ? !!O.value : !1
    })), A = u(() => `text-${a.textVariant || T(O.value)}`), L = u(() => {
      const ee = a.badgeOffset || "0px";
      return {
        fontSize: (g.indexOf($.value || null) === -1 ? `calc(${$.value} * ${y})` : "") || "",
        top: n.value ? ee : "",
        bottom: n.value ? "" : ee,
        left: l.value ? ee : "",
        right: l.value ? "" : ee
      };
    }), J = u(() => {
      const ee = g.indexOf($.value || null) === -1 ? `calc(${$.value} * ${m})` : null;
      return ee ? { fontSize: ee } : {};
    }), le = u(() => {
      var ye;
      const ee = ((ye = p == null ? void 0 : p.overlapScale) == null ? void 0 : ye.value) || 0, Y = $.value && ee ? `calc(${$.value} * -${ee})` : null;
      return Y ? { marginLeft: Y, marginRight: Y } : {};
    }), ae = u(() => r.value ? a.buttonType : "span"), X = u(() => ({
      ...le.value,
      width: $.value,
      height: $.value
    })), ue = (ee) => {
      !d.value && r.value && t("click", ee);
    }, se = (ee) => t("img-error", ee);
    return (ee, Y) => (c(), z(K(s(ae)), U({
      class: ["b-avatar", s(I)],
      style: s(X)
    }, s(w), { onClick: ue }), {
      default: E(() => [
        s(V) ? (c(), b("span", vn, [
          B(ee.$slots, "default")
        ])) : e.src ? (c(), b("span", bn, [
          q("img", {
            src: e.src,
            alt: e.alt,
            onError: se
          }, null, 40, mn)
        ])) : e.text ? (c(), b("span", {
          key: 2,
          class: F(["b-avatar-text", s(A)]),
          style: qe(s(J))
        }, D(e.text), 7)) : R("", !0),
        s(k) ? (c(), b("span", {
          key: 3,
          class: F(["b-avatar-badge", s(C)]),
          style: qe(s(L))
        }, [
          s(h) ? B(ee.$slots, "badge", { key: 0 }) : (c(), b("span", {
            key: 1,
            class: F(s(W))
          }, D(s(_)), 3))
        ], 6)) : R("", !0)
      ]),
      _: 3
    }, 16, ["class", "style"]));
  }
}), Ee = {
  active: { type: [Boolean, String], default: !1 },
  activeClass: { type: String, default: "router-link-active" },
  append: { type: [Boolean, String], default: !1 },
  disabled: { type: [Boolean, String], default: !1 },
  event: { type: [String, Array], default: "click" },
  exact: { type: [Boolean, String], default: !1 },
  exactActiveClass: { type: String, default: "router-link-exact-active" },
  href: { type: String },
  rel: { type: String, default: null },
  replace: { type: [Boolean, String], default: !1 },
  routerComponentName: { type: String, default: "router-link" },
  routerTag: { type: String, default: "a" },
  target: { type: String, default: "_self" },
  to: { type: [String, Object], default: null }
}, pn = x({
  props: Ee,
  emits: ["click"],
  setup(e, { emit: t, attrs: a }) {
    const l = i(o(e, "active")), n = i(o(e, "append")), r = i(o(e, "disabled")), d = i(o(e, "exact")), f = i(o(e, "replace")), v = nl(), g = M(null), m = u(() => {
      const V = e.routerComponentName.split("-").map((k) => k.charAt(0).toUpperCase() + k.slice(1)).join("");
      return !((v == null ? void 0 : v.appContext.app.component(V)) !== void 0) || r.value || !e.to ? "a" : e.routerComponentName;
    }), y = u(() => {
      const V = "#";
      if (e.href)
        return e.href;
      if (typeof e.to == "string")
        return e.to || V;
      const h = e.to;
      if (Object.prototype.toString.call(h) === "[object Object]" && (h.path || h.query || h.hash)) {
        const k = h.path || "", $ = h.query ? `?${Object.keys(h.query).map((N) => `${N}=${h.query[N]}`).join("=")}` : "", O = !h.hash || h.hash.charAt(0) === "#" ? h.hash || "" : `#${h.hash}`;
        return `${k}${$}${O}` || V;
      }
      return V;
    }), p = u(() => ({
      to: e.to,
      href: y.value,
      target: e.target,
      rel: e.target === "_blank" && e.rel === null ? "noopener" : e.rel || null,
      tabindex: r.value ? "-1" : typeof a.tabindex > "u" ? null : a.tabindex,
      "aria-disabled": r.value ? "true" : null
    }));
    return {
      tag: m,
      routerAttr: p,
      link: g,
      clicked: (V) => {
        if (r.value) {
          V.preventDefault(), V.stopImmediatePropagation();
          return;
        }
        t("click", V);
      },
      activeBoolean: l,
      appendBoolean: n,
      disabledBoolean: r,
      replaceBoolean: f,
      exactBoolean: d
    };
  }
}), he = (e, t) => {
  const a = e.__vccOpts || e;
  for (const [l, n] of t)
    a[l] = n;
  return a;
};
function hn(e, t, a, l, n, r) {
  return e.tag === "router-link" ? (c(), z(K(e.tag), U({ key: 0 }, e.routerAttr, { custom: "" }), {
    default: E(({ href: d, navigate: f, isActive: v, isExactActive: g }) => [
      (c(), z(K(e.routerTag), U({
        ref: "link",
        href: d,
        class: [v && e.activeClass, g && e.exactActiveClass]
      }, e.$attrs, { onClick: f }), {
        default: E(() => [
          B(e.$slots, "default")
        ]),
        _: 2
      }, 1040, ["href", "class", "onClick"]))
    ]),
    _: 3
  }, 16)) : (c(), z(K(e.tag), U({
    key: 1,
    ref: "link",
    class: { active: e.activeBoolean, disabled: e.disabledBoolean }
  }, e.routerAttr, { onClick: e.clicked }), {
    default: E(() => [
      B(e.$slots, "default")
    ]),
    _: 3
  }, 16, ["class", "onClick"]));
}
const ke = /* @__PURE__ */ he(pn, [["render", hn]]), Gt = ot(Ee, ["event", "routerTag"]), yn = x({
  components: { BLink: ke },
  props: {
    pill: { type: [Boolean, String], default: !1 },
    tag: { type: String, default: "span" },
    variant: { type: String, default: "secondary" },
    textIndicator: { type: [Boolean, String], default: !1 },
    dotIndicator: { type: [Boolean, String], default: !1 },
    ...Gt
  },
  setup(e) {
    const t = u(() => Ue(e)), a = u(() => t.value ? ke : e.tag), l = i(o(e, "pill")), n = i(o(e, "textIndicator")), r = i(o(e, "dotIndicator"));
    return {
      classes: u(() => ({
        [`bg-${e.variant}`]: e.variant,
        active: e.active,
        disabled: e.disabled,
        "text-dark": ["warning", "info", "light"].includes(e.variant),
        "rounded-pill": l.value,
        "position-absolute top-0 start-100 translate-middle": n.value || r.value,
        "p-2 border border-light rounded-circle": r.value,
        "text-decoration-none": t.value
      })),
      props: t.value ? fa(e, Gt) : {},
      computedTag: a
    };
  }
});
function Bn(e, t, a, l, n, r) {
  return c(), z(K(e.computedTag), U({
    class: ["badge", e.classes]
  }, e.props), {
    default: E(() => [
      B(e.$slots, "default")
    ]),
    _: 3
  }, 16, ["class"]);
}
const $n = /* @__PURE__ */ he(yn, [["render", Bn]]), kn = ot(Ee, ["event", "routerTag"]), Sn = x({
  components: { BLink: ke },
  props: {
    ...kn,
    active: { type: [Boolean, String], default: !1 },
    ariaCurrent: { type: String, default: "location" },
    disabled: { type: [Boolean, String], default: !1 },
    text: { type: String, required: !1 }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const a = i(o(e, "active")), l = i(o(e, "disabled")), n = u(() => ({
      active: a.value
    })), r = u(
      () => a.value ? "span" : ke
    ), d = u(
      () => a.value ? e.ariaCurrent : void 0
    );
    return {
      liClasses: n,
      computedTag: r,
      computedAriaCurrent: d,
      clicked: (v) => {
        if (l.value || a.value) {
          v.preventDefault(), v.stopImmediatePropagation();
          return;
        }
        l.value || t("click", v);
      }
    };
  }
});
function Cn(e, t, a, l, n, r) {
  return c(), b("li", {
    class: F(["breadcrumb-item", e.liClasses])
  }, [
    (c(), z(K(e.computedTag), U({ "aria-current": e.computedAriaCurrent }, e.$props, { onClick: e.clicked }), {
      default: E(() => [
        B(e.$slots, "default")
      ]),
      _: 3
    }, 16, ["aria-current", "onClick"]))
  ], 2);
}
const _a = /* @__PURE__ */ he(Sn, [["render", Cn]]), Tn = { "aria-label": "breadcrumb" }, wn = { class: "breadcrumb" }, Vn = /* @__PURE__ */ x({
  __name: "BBreadcrumb",
  props: {
    items: null
  },
  setup(e) {
    const t = e, a = jl(), l = u(() => {
      const n = t.items || (a == null ? void 0 : a.items) || [];
      let r = !1;
      return n.map((f, v) => (typeof f == "string" && (f = { text: f }, v < n.length - 1 && (f.href = "#")), f.active && (r = !0), !f.active && !r && (f.active = v + 1 === n.length), f));
    });
    return (n, r) => (c(), b("nav", Tn, [
      q("ol", wn, [
        B(n.$slots, "prepend"),
        (c(!0), b(oe, null, ve(s(l), (d, f) => (c(), z(_a, U({ key: f }, d), {
          default: E(() => [
            Z(D(d.text), 1)
          ]),
          _: 2
        }, 1040))), 128)),
        B(n.$slots, "default"),
        B(n.$slots, "append")
      ])
    ]));
  }
}), _n = {
  key: 0,
  class: "visually-hidden"
}, Pt = /* @__PURE__ */ x({
  __name: "BSpinner",
  props: {
    label: null,
    role: { default: "status" },
    small: { default: !1 },
    tag: { default: "span" },
    type: { default: "border" },
    variant: null
  },
  setup(e) {
    const t = e, a = i(o(t, "small")), l = u(() => ({
      "spinner-border": t.type === "border",
      "spinner-border-sm": t.type === "border" && a.value,
      "spinner-grow": t.type === "grow",
      "spinner-grow-sm": t.type === "grow" && a.value,
      [`text-${t.variant}`]: t.variant !== void 0
    }));
    return (n, r) => (c(), z(K(e.tag), {
      class: F(s(l)),
      role: e.label || n.$slots.label ? e.role : null,
      "aria-hidden": e.label || n.$slots.label ? null : !0
    }, {
      default: E(() => [
        e.label || n.$slots.label ? (c(), b("span", _n, [
          B(n.$slots, "label", {}, () => [
            Z(D(e.label), 1)
          ])
        ])) : R("", !0)
      ]),
      _: 3
    }, 8, ["class", "role", "aria-hidden"]));
  }
}), An = x({
  components: { BLink: ke, BSpinner: Pt },
  props: {
    ...Ee,
    active: { type: [Boolean, String], default: !1 },
    disabled: { type: [Boolean, String], default: !1 },
    href: { type: String, required: !1 },
    pill: { type: [Boolean, String], default: !1 },
    pressed: { type: [Boolean, String], default: !1 },
    rel: { type: String, default: void 0 },
    size: { type: String, default: "md" },
    squared: { type: [Boolean, String], default: !1 },
    tag: { type: String, default: "button" },
    target: { type: String, default: "_self" },
    type: { type: String, default: "button" },
    variant: { type: String, default: "secondary" },
    loading: { type: [Boolean, String], default: !1 },
    loadingMode: { type: String, default: "inline" }
  },
  emits: ["click", "update:pressed"],
  setup(e, { emit: t }) {
    const a = i(o(e, "active")), l = i(o(e, "disabled")), n = i(o(e, "pill")), r = i(o(e, "pressed")), d = i(o(e, "squared")), f = i(o(e, "loading")), v = u(() => r.value === !0), g = u(
      () => e.tag === "button" && e.href === void 0 && e.to === null
    ), m = u(() => Ue(e)), y = u(() => e.to !== null), p = u(
      () => e.href !== void 0 ? !1 : !g.value
    ), T = u(() => ({
      [`btn-${e.variant}`]: !!e.variant,
      [`btn-${e.size}`]: !!e.size,
      active: a.value || r.value,
      "rounded-pill": n.value,
      "rounded-0": d.value,
      disabled: l.value
    })), V = u(() => ({
      "aria-disabled": p.value ? l.value : null,
      "aria-pressed": v.value ? r.value : null,
      autocomplete: v.value ? "off" : null,
      disabled: g.value ? l.value : null,
      href: e.href,
      rel: m.value ? e.rel : null,
      role: p.value || m.value ? "button" : null,
      target: m.value ? e.target : null,
      type: g.value ? e.type : null,
      to: g.value ? null : e.to,
      append: m.value ? e.append : null,
      activeClass: y.value ? e.activeClass : null,
      event: y.value ? e.event : null,
      exact: y.value ? e.exact : null,
      exactActiveClass: y.value ? e.exactActiveClass : null,
      replace: y.value ? e.replace : null,
      routerComponentName: y.value ? e.routerComponentName : null,
      routerTag: y.value ? e.routerTag : null
    })), h = u(
      () => y.value ? ke : e.href ? "a" : e.tag
    );
    return {
      classes: T,
      attrs: V,
      computedTag: h,
      clicked: ($) => {
        if (l.value) {
          $.preventDefault(), $.stopPropagation();
          return;
        }
        t("click", $), v.value && t("update:pressed", !r.value);
      },
      loadingBoolean: f
    };
  }
});
function xn(e, t, a, l, n, r) {
  const d = It("b-spinner");
  return c(), z(K(e.computedTag), U({
    class: ["btn", e.classes]
  }, e.attrs, { onClick: e.clicked }), {
    default: E(() => [
      e.loadingBoolean ? (c(), b("div", {
        key: 0,
        class: F(["btn-loading", { "mode-fill": e.loadingMode === "fill", "mode-inline": e.loadingMode === "inline" }])
      }, [
        B(e.$slots, "loading", {}, () => [
          Se(d, {
            class: "btn-spinner",
            small: e.size !== "lg"
          }, null, 8, ["small"])
        ])
      ], 2)) : R("", !0),
      q("div", {
        class: F(["btn-content", { "btn-loading-fill": e.loadingBoolean && e.loadingMode === "fill" }])
      }, [
        B(e.$slots, "default")
      ], 2)
    ]),
    _: 3
  }, 16, ["class", "onClick"]);
}
const We = /* @__PURE__ */ he(An, [["render", xn]]), In = /* @__PURE__ */ x({
  __name: "BButtonGroup",
  props: {
    ariaLabel: { default: "Group" },
    size: null,
    tag: { default: "div" },
    vertical: { default: !1 }
  },
  setup(e) {
    const t = e, a = i(o(t, "vertical")), l = u(() => ({
      "btn-group": !a.value && t.size === void 0,
      [`btn-group-${t.size}`]: t.size !== void 0,
      "btn-group-vertical": a.value
    }));
    return (n, r) => (c(), z(K(e.tag), {
      class: F(s(l)),
      role: "group",
      "aria-label": e.ariaLabel
    }, {
      default: E(() => [
        B(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "aria-label"]));
  }
}), Fn = ["aria-label"], On = /* @__PURE__ */ x({
  __name: "BButtonToolbar",
  props: {
    ariaLabel: { default: "Group" },
    justify: { default: !1 }
  },
  setup(e) {
    const a = i(o(e, "justify")), l = u(() => ({
      "justify-content-between": a.value
    }));
    return (n, r) => (c(), b("div", {
      class: F([s(l), "btn-toolbar"]),
      role: "toolbar",
      "aria-label": e.ariaLabel
    }, [
      B(n.$slots, "default")
    ], 10, Fn));
  }
}), St = /* @__PURE__ */ x({
  __name: "BCardImg",
  props: {
    alt: { default: void 0 },
    bottom: { default: !1 },
    end: { default: !1 },
    height: null,
    left: { default: !1 },
    right: { default: !1 },
    src: null,
    lazy: { default: !1 },
    start: { default: !1 },
    top: { default: !1 },
    width: null
  },
  setup(e) {
    const t = e, a = i(o(t, "bottom")), l = i(o(t, "end")), n = i(o(t, "left")), r = i(o(t, "right")), d = i(o(t, "start")), f = i(o(t, "top")), v = i(o(t, "lazy")), g = u(() => ({
      loading: v.value ? "lazy" : "eager",
      src: t.src,
      alt: t.alt,
      width: (typeof t.width == "number" ? t.width : parseInt(t.width, 10)) || void 0,
      height: (typeof t.height == "number" ? t.height : parseInt(t.height, 10)) || void 0
    })), m = u(
      () => n.value ? "float-start" : r.value ? "float-end" : ""
    ), y = u(
      () => f.value ? "card-img-top" : r.value || l.value ? "card-img-right" : a.value ? "card-img-bottom" : n.value || d.value ? "card-img-left" : "card-img"
    ), p = u(() => ({
      [m.value]: !!m.value,
      [y.value]: !!y.value
    }));
    return (T, V) => (c(), b("img", U({ class: s(p) }, s(g)), null, 16));
  }
}), zn = ["innerHTML"], Aa = /* @__PURE__ */ x({
  __name: "BCardHeadFoot",
  props: {
    text: null,
    bgVariant: null,
    borderVariant: null,
    html: null,
    tag: { default: "div" },
    textVariant: null
  },
  setup(e) {
    const t = e, a = u(() => ({
      [`text-${t.textVariant}`]: t.textVariant !== void 0,
      [`bg-${t.bgVariant}`]: t.bgVariant !== void 0,
      [`border-${t.borderVariant}`]: t.borderVariant !== void 0
    }));
    return (l, n) => (c(), z(K(e.tag), {
      class: F(s(a))
    }, {
      default: E(() => [
        e.html ? (c(), b("div", {
          key: 0,
          innerHTML: e.html
        }, null, 8, zn)) : B(l.$slots, "default", { key: 1 }, () => [
          Z(D(e.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), xa = /* @__PURE__ */ x({
  __name: "BCardHeader",
  props: {
    text: null,
    bgVariant: null,
    borderVariant: null,
    html: null,
    tag: { default: "div" },
    textVariant: null
  },
  setup(e) {
    return (t, a) => (c(), z(Aa, U({ class: "card-header" }, t.$props), {
      default: E(() => [
        B(t.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Ia = /* @__PURE__ */ x({
  __name: "BCardTitle",
  props: {
    text: null,
    tag: { default: "h4" }
  },
  setup(e) {
    return (t, a) => (c(), z(K(e.tag), { class: "card-title" }, {
      default: E(() => [
        B(t.$slots, "default", {}, () => [
          Z(D(e.text), 1)
        ])
      ]),
      _: 3
    }));
  }
}), Fa = /* @__PURE__ */ x({
  __name: "BCardSubTitle",
  props: {
    text: null,
    tag: { default: "h6" },
    textVariant: { default: "muted" }
  },
  setup(e) {
    const t = e, a = u(() => ({
      [`text-${t.textVariant}`]: !!t.textVariant
    }));
    return (l, n) => (c(), z(K(e.tag), {
      class: F(["card-subtitle mb-2", s(a)])
    }, {
      default: E(() => [
        B(l.$slots, "default", {}, () => [
          Z(D(e.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Oa = /* @__PURE__ */ x({
  __name: "BCardBody",
  props: {
    bodyBgVariant: null,
    bodyTag: { default: "div" },
    bodyTextVariant: null,
    overlay: { default: !1 },
    subTitle: null,
    subTitleTag: { default: "h4" },
    subTitleTextVariant: null,
    title: null,
    titleTag: { default: "h4" },
    text: null
  },
  setup(e) {
    const t = e, a = i(o(t, "overlay")), l = u(() => ({
      "card-img-overlay": a.value,
      [`text-${t.bodyTextVariant}`]: t.bodyTextVariant !== void 0,
      [`bg-${t.bodyBgVariant}`]: t.bodyBgVariant !== void 0
    }));
    return (n, r) => (c(), z(K(e.bodyTag), {
      class: F(["card-body", s(l)])
    }, {
      default: E(() => [
        !!e.title || n.$slots.title ? (c(), z(Ia, {
          key: 0,
          tag: e.titleTag
        }, {
          default: E(() => [
            B(n.$slots, "title", {}, () => [
              Z(D(e.title), 1)
            ])
          ]),
          _: 3
        }, 8, ["tag"])) : R("", !0),
        !!e.subTitle || !!n.$slots.subTitle ? (c(), z(Fa, {
          key: 1,
          tag: e.subTitleTag,
          "text-variant": e.subTitleTextVariant
        }, {
          default: E(() => [
            B(n.$slots, "subTitle", {}, () => [
              Z(D(e.subTitle), 1)
            ])
          ]),
          _: 3
        }, 8, ["tag", "text-variant"])) : R("", !0),
        B(n.$slots, "default", {}, () => [
          Z(D(e.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), za = /* @__PURE__ */ x({
  __name: "BCardFooter",
  props: {
    text: null,
    bgVariant: null,
    borderVariant: null,
    html: null,
    tag: { default: "div" },
    textVariant: null
  },
  setup(e) {
    return (t, a) => (c(), z(Aa, U({ class: "card-footer" }, t.$props), {
      default: E(() => [
        B(t.$slots, "default", {}, () => [
          Z(D(e.text), 1)
        ])
      ]),
      _: 3
    }, 16));
  }
}), Pn = /* @__PURE__ */ x({
  __name: "BCard",
  props: {
    align: null,
    bgVariant: null,
    bodyBgVariant: null,
    bodyClass: null,
    bodyTag: { default: "div" },
    bodyTextVariant: null,
    borderVariant: null,
    footer: null,
    footerBgVariant: null,
    footerBorderVariant: null,
    footerClass: null,
    footerHtml: { default: "" },
    footerTag: { default: "div" },
    footerTextVariant: null,
    header: null,
    headerBgVariant: null,
    headerBorderVariant: null,
    headerClass: null,
    headerHtml: { default: "" },
    headerTag: { default: "div" },
    headerTextVariant: null,
    imgAlt: null,
    imgBottom: { default: !1 },
    imgEnd: { default: !1 },
    imgHeight: null,
    imgLeft: { default: !1 },
    imgRight: { default: !1 },
    imgSrc: null,
    imgStart: { default: !1 },
    imgTop: { default: !1 },
    imgWidth: null,
    noBody: { default: !1 },
    overlay: { default: !1 },
    subTitle: null,
    subTitleTag: { default: "h6" },
    subTitleTextVariant: { default: "muted" },
    tag: { default: "div" },
    textVariant: null,
    title: null,
    titleTag: { default: "h4" },
    bodyText: { default: "" }
  },
  setup(e) {
    const t = e, a = i(o(t, "imgBottom")), l = i(o(t, "imgEnd")), n = i(o(t, "imgLeft")), r = i(o(t, "imgRight")), d = i(o(t, "imgStart")), f = i(o(t, "noBody")), v = u(() => ({
      [`text-${t.align}`]: t.align !== void 0,
      [`text-${t.textVariant}`]: t.textVariant !== void 0,
      [`bg-${t.bgVariant}`]: t.bgVariant !== void 0,
      [`border-${t.borderVariant}`]: t.borderVariant !== void 0,
      "flex-row": n.value || d.value,
      "flex-row-reverse": l.value || r.value
    })), g = u(() => ({
      bgVariant: t.headerBgVariant,
      borderVariant: t.headerBorderVariant,
      html: t.headerHtml,
      tag: t.headerTag,
      textVariant: t.headerTextVariant
    })), m = u(() => ({
      overlay: t.overlay,
      bodyBgVariant: t.bodyBgVariant,
      bodyTag: t.bodyTag,
      bodyTextVariant: t.bodyTextVariant,
      subTitle: t.subTitle,
      subTitleTag: t.subTitleTag,
      subTitleTextVariant: t.subTitleTextVariant,
      title: t.title,
      titleTag: t.titleTag
    })), y = u(() => ({
      bgVariant: t.footerBgVariant,
      borderVariant: t.footerBorderVariant,
      html: t.footerHtml,
      tag: t.footerTag,
      textVariant: t.footerTextVariant
    })), p = u(() => ({
      src: t.imgSrc,
      alt: t.imgAlt,
      height: t.imgHeight,
      width: t.imgWidth,
      bottom: t.imgBottom,
      end: t.imgEnd,
      left: t.imgLeft,
      right: t.imgRight,
      start: t.imgStart,
      top: t.imgTop
    }));
    return (T, V) => (c(), z(K(e.tag), {
      class: F(["card", s(v)])
    }, {
      default: E(() => [
        e.imgSrc && !s(a) ? (c(), z(St, Ce(U({ key: 0 }, s(p))), null, 16)) : R("", !0),
        e.header || T.$slots.header || e.headerHtml ? (c(), z(xa, U({ key: 1 }, s(g), { class: e.headerClass }), {
          default: E(() => [
            B(T.$slots, "header", {}, () => [
              Z(D(e.header), 1)
            ])
          ]),
          _: 3
        }, 16, ["class"])) : R("", !0),
        s(f) ? B(T.$slots, "default", { key: 3 }, () => [
          Z(D(e.bodyText), 1)
        ]) : (c(), z(Oa, U({ key: 2 }, s(m), { class: e.bodyClass }), {
          default: E(() => [
            B(T.$slots, "default", {}, () => [
              Z(D(e.bodyText), 1)
            ])
          ]),
          _: 3
        }, 16, ["class"])),
        e.footer || T.$slots.footer || e.footerHtml ? (c(), z(za, U({ key: 4 }, s(y), { class: e.footerClass }), {
          default: E(() => [
            B(T.$slots, "footer", {}, () => [
              Z(D(e.footer), 1)
            ])
          ]),
          _: 3
        }, 16, ["class"])) : R("", !0),
        e.imgSrc && s(a) ? (c(), z(St, Ce(U({ key: 5 }, s(p))), null, 16)) : R("", !0)
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Nn = /* @__PURE__ */ x({
  __name: "BCardGroup",
  props: {
    columns: { default: !1 },
    deck: { default: !1 },
    tag: { default: "div" }
  },
  setup(e) {
    const t = e, a = i(o(t, "columns")), l = i(o(t, "deck")), n = u(
      () => l.value ? "card-deck" : a.value ? "card-columns" : "card-group"
    ), r = u(() => ({
      [n.value]: !!n.value
    }));
    return (d, f) => (c(), z(K(e.tag), {
      class: F(s(r))
    }, {
      default: E(() => [
        B(d.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Ln = /* @__PURE__ */ x({
  __name: "BCardText",
  props: {
    text: null,
    tag: { default: "p" }
  },
  setup(e) {
    return (t, a) => (c(), z(K(e.tag), { class: "card-text" }, {
      default: E(() => [
        B(t.$slots, "default", {}, () => [
          Z(D(e.text), 1)
        ])
      ]),
      _: 3
    }));
  }
}), En = ["id"], Hn = {
  key: 0,
  class: "carousel-indicators"
}, Dn = ["data-bs-target", "data-bs-slide-to", "aria-label"], qn = { class: "carousel-inner" }, Rn = ["data-bs-target"], jn = /* @__PURE__ */ q("span", {
  class: "carousel-control-prev-icon",
  "aria-hidden": "true"
}, null, -1), Mn = { class: "visually-hidden" }, Gn = ["data-bs-target"], Un = /* @__PURE__ */ q("span", {
  class: "carousel-control-next-icon",
  "aria-hidden": "true"
}, null, -1), Wn = { class: "visually-hidden" }, Pa = Symbol(), Xn = /* @__PURE__ */ x({
  __name: "BCarousel",
  props: {
    id: null,
    imgHeight: null,
    imgWidth: null,
    background: null,
    modelValue: { default: 0 },
    controls: { default: !1 },
    indicators: { default: !1 },
    interval: { default: 5e3 },
    noTouch: { default: !1 },
    noWrap: { default: !1 },
    controlsPrevText: { default: "Previous" },
    controlsNextText: { default: "Next" },
    indicatorsButtonLabel: { default: "Slide" }
  },
  emits: ["sliding-start", "sliding-end"],
  setup(e, { emit: t }) {
    const a = e, l = i(o(a, "controls")), n = i(o(a, "indicators")), r = i(o(a, "noTouch"));
    i(o(a, "noWrap"));
    const d = Le(), f = M(), v = M(), g = ge(o(a, "id"), "accordion"), m = M([]);
    return fe(f, "slide.bs.carousel", (y) => t("sliding-start", y)), fe(f, "slid.bs.carousel", (y) => t("sliding-end", y)), me(() => {
      v.value = new ml(f.value, {
        wrap: !r.value,
        interval: a.interval,
        touch: !r.value
      }), d.default && (m.value = d.default().filter((y) => {
        var p;
        return ((p = y.type) == null ? void 0 : p.name) === "BCarouselSlide";
      }));
    }), je(Pa, {
      background: a.background,
      width: a.imgWidth,
      height: a.imgHeight
    }), (y, p) => (c(), b("div", {
      id: s(g),
      ref_key: "element",
      ref: f,
      class: "carousel slide",
      "data-bs-ride": "carousel"
    }, [
      s(n) ? (c(), b("div", Hn, [
        (c(!0), b(oe, null, ve(m.value, (T, V) => (c(), b("button", {
          key: V,
          type: "button",
          "data-bs-target": `#${s(g)}`,
          "data-bs-slide-to": V,
          class: F(V === 0 ? "active" : ""),
          "aria-current": "true",
          "aria-label": `${e.indicatorsButtonLabel} ${V}`
        }, null, 10, Dn))), 128))
      ])) : R("", !0),
      q("div", qn, [
        B(y.$slots, "default")
      ]),
      s(l) ? (c(), b(oe, { key: 1 }, [
        q("button", {
          class: "carousel-control-prev",
          type: "button",
          "data-bs-target": `#${s(g)}`,
          "data-bs-slide": "prev"
        }, [
          jn,
          q("span", Mn, D(e.controlsPrevText), 1)
        ], 8, Rn),
        q("button", {
          class: "carousel-control-next",
          type: "button",
          "data-bs-target": `#${s(g)}`,
          "data-bs-slide": "next"
        }, [
          Un,
          q("span", Wn, D(e.controlsNextText), 1)
        ], 8, Gn)
      ], 64)) : R("", !0)
    ], 8, En));
  }
}), Na = /* @__PURE__ */ x({
  __name: "BImg",
  props: {
    alt: null,
    blank: { default: !1 },
    blankColor: { default: "transparent" },
    block: { default: !1 },
    center: { default: !1 },
    fluid: { default: !1 },
    lazy: { default: !1 },
    fluidGrow: { default: !1 },
    height: null,
    left: { default: !1 },
    right: { default: !1 },
    rounded: { type: [Boolean, String], default: !1 },
    sizes: null,
    src: null,
    srcset: null,
    thumbnail: { default: !1 },
    width: null
  },
  emits: ["load"],
  setup(e, { emit: t }) {
    const a = e, l = i(o(a, "lazy")), n = i(o(a, "blank")), r = i(o(a, "block")), d = i(o(a, "center")), f = i(o(a, "fluid")), v = i(o(a, "fluidGrow")), g = i(o(a, "left")), m = i(o(a, "right")), y = i(o(a, "thumbnail")), p = '<svg width="%{w}" height="%{h}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 %{w} %{h}" preserveAspectRatio="none"><rect width="100%" height="100%" style="fill:%{f};"></rect></svg>', T = (C, _, W) => `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(
      p.replace("%{w}", String(C)).replace("%{h}", String(_)).replace("%{f}", W)
    )}`, V = u(
      () => typeof a.srcset == "string" ? a.srcset.split(",").filter((C) => C).join(",") : Array.isArray(a.srcset) ? a.srcset.filter((C) => C).join(",") : void 0
    ), h = u(
      () => typeof a.sizes == "string" ? a.sizes.split(",").filter((C) => C).join(",") : Array.isArray(a.sizes) ? a.sizes.filter((C) => C).join(",") : void 0
    ), k = u(() => {
      const C = typeof a.width == "number" ? a.width : parseInt(a.width, 10) || void 0, _ = typeof a.height == "number" ? a.height : parseInt(a.height, 10) || void 0;
      if (n.value) {
        if (!!C && !_)
          return { height: C, width: C };
        if (!C && !!_)
          return { height: _, width: _ };
        if (!C && !_)
          return { height: 1, width: 1 };
      }
      return {
        width: C,
        height: _
      };
    }), $ = u(
      () => T(
        k.value.width,
        k.value.height,
        a.blankColor || "transparent"
      )
    ), O = u(() => ({
      src: n.value ? $.value : a.src,
      alt: a.alt,
      width: k.value.width || void 0,
      height: k.value.height || void 0,
      srcset: n.value ? void 0 : V.value,
      sizes: n.value ? void 0 : h.value,
      loading: l.value ? "lazy" : "eager"
    })), N = u(
      () => g.value ? "float-start" : m.value ? "float-end" : d.value ? "mx-auto" : void 0
    ), w = u(() => ({
      "img-thumbnail": y.value,
      "img-fluid": f.value || v.value,
      "w-100": v.value,
      rounded: a.rounded === "" || a.rounded === !0,
      [`rounded-${a.rounded}`]: typeof a.rounded == "string" && a.rounded !== "",
      [`${N.value}`]: N.value !== void 0,
      "d-block": r.value || d.value
    }));
    return (C, _) => (c(), b("img", U({ class: s(w) }, s(O), {
      onLoad: _[0] || (_[0] = (W) => t("load", W))
    }), null, 16));
  }
}), Kn = ["id", "data-bs-interval"], Jn = ["innerHTML"], Yn = { key: 1 }, Zn = ["innerHTML"], Qn = { key: 1 }, eo = /* @__PURE__ */ x({
  __name: "BCarouselSlide",
  props: {
    imgSrc: null,
    imgHeight: null,
    imgWidth: null,
    interval: null,
    active: { default: !1 },
    background: null,
    caption: null,
    captionHtml: null,
    captionTag: { default: "h3" },
    contentTag: { default: "div" },
    contentVisibleUp: null,
    id: null,
    imgAlt: null,
    imgBlank: { default: !1 },
    imgBlankColor: { default: "transparent" },
    text: null,
    textHtml: null,
    textTag: { default: "p" }
  },
  setup(e) {
    const t = e, a = i(o(t, "active")), l = i(o(t, "imgBlank")), n = Ie(Pa, {}), r = ge(o(t, "id"), "accordion");
    u(
      () => l.value ? l.value : t.imgSrc
    );
    const d = u(() => ({
      background: `${t.background || n.background || "rgb(171, 171, 171)"} none repeat scroll 0% 0%`
    })), f = u(() => ({
      "d-none": t.contentVisibleUp !== void 0,
      [`d-${t.contentVisibleUp}-block`]: t.contentVisibleUp !== void 0
    })), v = u(() => n.width), g = u(() => n.height);
    return (m, y) => (c(), b("div", {
      id: s(r),
      class: F(["carousel-item", { active: s(a) }]),
      "data-bs-interval": e.interval,
      style: qe(s(d))
    }, [
      B(m.$slots, "img", {}, () => [
        Se(Na, {
          class: "d-block w-100",
          alt: e.imgAlt,
          src: e.imgSrc,
          width: e.imgWidth || s(v),
          height: e.imgHeight || s(g),
          blank: s(l),
          "blank-color": e.imgBlankColor
        }, null, 8, ["alt", "src", "width", "height", "blank", "blank-color"])
      ]),
      e.caption || e.captionHtml || e.text || e.textHtml || m.$slots.default ? (c(), z(K(e.contentTag), {
        key: 0,
        class: F(["carousel-caption", s(f)])
      }, {
        default: E(() => [
          e.caption || e.captionHtml ? (c(), z(K(e.captionTag), { key: 0 }, {
            default: E(() => [
              e.captionHtml ? (c(), b("span", {
                key: 0,
                innerHTML: e.captionHtml
              }, null, 8, Jn)) : (c(), b("span", Yn, D(e.caption), 1))
            ]),
            _: 1
          })) : R("", !0),
          e.text || e.textHtml ? (c(), z(K(e.textTag), { key: 1 }, {
            default: E(() => [
              e.textHtml ? (c(), b("span", {
                key: 0,
                innerHTML: e.textHtml
              }, null, 8, Zn)) : (c(), b("span", Qn, D(e.text), 1))
            ]),
            _: 1
          })) : R("", !0),
          B(m.$slots, "default")
        ]),
        _: 3
      }, 8, ["class"])) : R("", !0)
    ], 14, Kn));
  }
}), Ut = it("", [], { type: [Boolean, String, Number], default: !1 }), Wt = it("offset", [""], { type: [String, Number], default: null }), Xt = it("order", [""], { type: [String, Number], default: null }), to = x({
  name: "BCol",
  props: {
    col: { type: [Boolean, String], default: !1 },
    cols: { type: [String, Number], default: null },
    ...Ut,
    offset: { type: [String, Number], default: null },
    ...Wt,
    order: { type: [String, Number], default: null },
    ...Xt,
    alignSelf: { type: String, default: null },
    tag: { type: String, default: "div" }
  },
  setup(e) {
    const t = i(o(e, "col")), a = [
      { content: Ut, propPrefix: "cols", classPrefix: "col" },
      { content: Wt, propPrefix: "offset" },
      { content: Xt, propPrefix: "order" }
    ], l = u(
      () => a.flatMap((r) => ca(e, r.content, r.propPrefix, r.classPrefix))
    );
    return {
      classes: u(() => ({
        col: t.value || !l.value.some((r) => /^col-/.test(r) && !e.cols),
        [`col-${e.cols}`]: !!e.cols,
        [`offset-${e.offset}`]: !!e.offset,
        [`order-${e.order}`]: !!e.order,
        [`align-self-${e.alignSelf}`]: !!e.alignSelf
      })),
      classList: l
    };
  }
});
function ao(e, t, a, l, n, r) {
  return c(), z(K(e.tag), {
    class: F([e.classes, e.classList])
  }, {
    default: E(() => [
      B(e.$slots, "default")
    ]),
    _: 3
  }, 8, ["class"]);
}
const Ge = /* @__PURE__ */ he(to, [["render", ao]]), La = {
  name: "",
  enterActiveClass: "",
  enterToClass: "",
  leaveActiveClass: "",
  leaveToClass: "showing",
  enterFromClass: "showing",
  leaveFromClass: ""
}, lo = {
  ...La,
  enterActiveClass: "fade showing",
  leaveActiveClass: "fade showing"
}, lt = x({
  props: {
    appear: { type: [Boolean, String], default: !1 },
    mode: { type: String, required: !1 },
    noFade: { type: [Boolean, String], default: !1 },
    transProps: { type: Object, required: !1 }
  },
  setup(e, { slots: t }) {
    const a = i(o(e, "appear")), l = i(o(e, "noFade")), n = M(e.transProps);
    return na(n.value) || (n.value = l.value ? La : lo, a.value && (n.value = {
      ...n.value,
      appear: !0,
      appearClass: n.value.enterClass,
      appearActiveClass: n.value.enterActiveClass,
      appearToClass: n.value.enterToClass
    })), n.value = {
      mode: e.mode,
      ...n.value,
      css: !0
    }, () => Q(
      ol,
      { ...n.value },
      {
        default: () => t.default ? t.default() : []
      }
    );
  }
}), no = "toast-title", Kt = 1e3, Ea = x({
  components: { BLink: ke },
  props: {
    ...Ee,
    delay: { type: Number, default: 5e3 },
    bodyClass: { type: String },
    body: { type: [Object, String] },
    headerClass: { type: String },
    headerTag: { type: String, default: "div" },
    animation: { type: [Boolean, String], default: !0 },
    id: { type: String },
    isStatus: { type: [Boolean, String], default: !1 },
    autoHide: { type: [Boolean, String], default: !0 },
    noCloseButton: { type: [Boolean, String], default: !1 },
    noFade: { type: [Boolean, String], default: !1 },
    noHoverPause: { type: [Boolean, String], default: !1 },
    solid: { type: [Boolean, String], default: !1 },
    static: { type: [Boolean, String], default: !1 },
    title: { type: String },
    modelValue: { type: [Boolean, String], default: !1 },
    toastClass: { type: Array },
    variant: { type: String }
  },
  emits: ["destroyed", "update:modelValue"],
  setup(e, { emit: t, slots: a }) {
    i(o(e, "animation"));
    const l = i(o(e, "isStatus")), n = i(o(e, "autoHide")), r = i(o(e, "noCloseButton")), d = i(o(e, "noFade")), f = i(o(e, "noHoverPause"));
    i(o(e, "solid")), i(o(e, "static"));
    const v = i(o(e, "modelValue")), g = M(!1), m = M(!1), y = M(!1), p = u(() => ({
      [`b-toast-${e.variant}`]: e.variant !== void 0,
      show: y.value || g.value
    }));
    let T, V, h;
    const k = () => {
      typeof T > "u" || (clearTimeout(T), T = void 0);
    }, $ = u(
      () => Math.max(Re(e.delay, 0), Kt)
    ), O = () => {
      v.value && (V = h = 0, k(), m.value = !0, Je(() => {
        y.value = !1;
      }));
    }, N = () => {
      k(), t("update:modelValue", !0), V = h = 0, m.value = !1, Fe(() => {
        Je(() => {
          y.value = !0;
        });
      });
    }, w = () => {
      if (!n.value || f.value || !T || h)
        return;
      const le = Date.now() - V;
      le > 0 && (k(), h = Math.max($.value - le, Kt));
    }, C = () => {
      (!n.value || f.value || !h) && (h = V = 0), _();
    };
    ie(
      () => v.value,
      (le) => {
        le ? N() : O();
      }
    );
    const _ = () => {
      k(), n.value && (T = setTimeout(O, h || $.value), V = Date.now(), h = 0);
    }, W = () => {
      g.value = !0, t("update:modelValue", !0);
    }, I = () => {
      g.value = !1, _();
    }, A = () => {
      g.value = !0;
    }, L = () => {
      g.value = !1, h = V = 0, t("update:modelValue", !1);
    };
    sl(() => {
      k(), n.value && t("destroyed", e.id);
    }), me(() => {
      Fe(() => {
        v.value && Je(() => {
          N();
        });
      });
    });
    const J = () => {
      Fe(() => {
        Je(() => {
          O();
        });
      });
    };
    return () => {
      const le = () => {
        const ae = [], X = $e(no, { hide: O }, a);
        X ? ae.push(Q(X)) : e.title && ae.push(Q("strong", { class: "me-auto" }, e.title)), !r.value && ae.length !== 0 && ae.push(
          Q(Me, {
            class: ["btn-close"],
            onClick: () => {
              O();
            }
          })
        );
        const ue = [];
        if (ae.length > 0 && ue.push(
          Q(
            e.headerTag,
            {
              class: "toast-header"
            },
            { default: () => ae }
          )
        ), $e("default", { hide: O }, a) || e.body) {
          const se = Q(
            Ue(e) ? "b-link" : "div",
            {
              class: ["toast-body", e.bodyClass],
              onClick: Ue(e) ? { click: J } : {}
            },
            $e("default", { hide: O }, a) || e.body
          );
          ue.push(se);
        }
        return Q(
          "div",
          {
            class: ["toast", e.toastClass, p.value],
            tabindex: "0"
          },
          ue
        );
      };
      return Q(
        "div",
        {
          class: ["b-toast"],
          id: e.id,
          role: m.value ? null : l.value ? "status" : "alert",
          "aria-live": m.value ? null : l.value ? "polite" : "assertive",
          "aria-atomic": m.value ? null : "true",
          onmouseenter: w,
          onmouseleave: C
        },
        [
          Q(
            lt,
            {
              noFade: d.value,
              onAfterEnter: I,
              onBeforeEnter: W,
              onAfterLeave: L,
              onBeforeLeave: A
            },
            () => [y.value ? le() : ""]
          )
        ]
      );
    };
  }
}), Ct = /* @__PURE__ */ x({
  __name: "BToaster",
  props: {
    position: { default: "top-right" },
    instance: null
  },
  setup(e) {
    const t = e, a = {
      "top-left": "top-0 start-0",
      "top-center": "top-0 start-50 translate-middle-x",
      "top-right": "top-0 end-0",
      "middle-left": "top-50 start-0 translate-middle-y",
      "middle-center": "top-50 start-50 translate-middle",
      "middle-right": "top-50 end-0 translate-middle-y",
      "bottom-left": "bottom-0 start-0",
      "bottom-center": "bottom-0 start-50 translate-middle-x",
      "bottom-right": "bottom-0 end-0"
    }, l = u(() => a[t.position]), n = (r) => {
      var d;
      (d = t.instance) == null || d.remove(r);
    };
    return (r, d) => {
      var f;
      return c(), b("div", {
        class: F([[s(l)], "b-toaster position-fixed p-3"]),
        style: { "z-index": "11" }
      }, [
        (c(!0), b(oe, null, ve((f = e.instance) == null ? void 0 : f.toasts(e.position).value, (v) => (c(), z(Ea, {
          id: v.options.id,
          key: v.options.id,
          modelValue: v.options.value,
          "onUpdate:modelValue": (g) => v.options.value = g,
          delay: v.options.delay,
          title: v.content.title,
          body: v.content.body,
          component: v.content.body,
          variant: v.options.variant,
          onDestroyed: n
        }, null, 8, ["id", "modelValue", "onUpdate:modelValue", "delay", "title", "body", "component", "variant"]))), 128))
      ], 2);
    };
  }
}), He = { delay: 5e3, value: !0, pos: "top-right" };
class Jt {
  constructor(t) {
    ce(this, "vm");
    ce(this, "containerPositions");
    il(t) ? this.vm = t : this.vm = Ae(t), this.containerPositions = u(() => {
      const a = /* @__PURE__ */ new Set([]);
      return this.vm.toasts.map((l) => {
        l.options.pos && a.add(l.options.pos);
      }), a;
    });
  }
  toasts(t) {
    return t ? u(
      () => this.vm.toasts.filter((a) => {
        if (a.options.pos === t && a.options.value)
          return a;
      })
    ) : u(() => this.vm.toasts);
  }
  remove(...t) {
    this.vm.toasts = this.vm.toasts.filter((a) => {
      if (a.options.id && !t.includes(a.options.id))
        return a;
    });
  }
  isRoot() {
    var t;
    return (t = this.vm.root) != null ? t : !1;
  }
  show(t, a = He) {
    const l = { id: _e(), ...He, ...a }, n = {
      options: Ae(l),
      content: t
    };
    return this.vm.toasts.push(n), n;
  }
  info(t, a = He) {
    return this.show(t, { variant: "info", ...a });
  }
  danger(t, a = He) {
    return this.show(t, { variant: "danger", ...a });
  }
  warning(t, a = He) {
    return this.show(t, { variant: "warning", ...a });
  }
  success(t, a = He) {
    return this.show(t, { variant: "success", ...a });
  }
  hide() {
  }
}
class oo {
  constructor() {
    ce(this, "vms");
    ce(this, "rootInstance");
    ce(this, "useToast", Da);
    this.vms = {};
  }
  getOrCreateViewModel(t) {
    if (!t) {
      if (this.rootInstance)
        return this.vms[this.rootInstance];
      const a = { root: !0, toasts: [], container: void 0, id: Symbol("toast") };
      return this.rootInstance = a.id, this.vms[a.id] = a, a;
    }
    if (t.root) {
      if (this.rootInstance)
        return this.vms[this.rootInstance];
      this.rootInstance = t.id;
    }
    return this.vms[t.id] = t, t;
  }
  getVM(t) {
    if (!t && this.rootInstance)
      return this.vms[this.rootInstance];
    if (t)
      return this.vms[t];
  }
}
const Tt = Symbol(), Ha = Symbol(), so = {
  container: void 0,
  toasts: [],
  root: !1
};
function io() {
  return Ie(Ha);
}
function Da(e, t = Tt) {
  const a = Ie(io());
  if (!e)
    return new Jt(a.getOrCreateViewModel());
  const l = { id: Symbol("toastInstance") }, n = { ...so, ...l, ...e }, r = a.getOrCreateViewModel(n);
  return new Jt(r);
}
const ro = {
  install: (e, t = {}) => {
    var a, l, n, r;
    e.provide(Ha, (l = (a = t == null ? void 0 : t.BToast) == null ? void 0 : a.injectkey) != null ? l : Tt), e.provide((r = (n = t == null ? void 0 : t.BToast) == null ? void 0 : n.injectkey) != null ? r : Tt, new oo());
  }
}, uo = x({
  name: "BContainer",
  props: {
    gutterX: { type: String, default: null },
    gutterY: { type: String, default: null },
    fluid: { type: [Boolean, String], default: !1 },
    toast: { type: Object },
    position: { type: String, required: !1 },
    tag: { type: String, default: "div" }
  },
  setup(e, { slots: t, expose: a }) {
    const l = M();
    let n;
    const r = u(() => ({
      container: !e.fluid,
      ["container-fluid"]: typeof e.fluid == "boolean" && e.fluid,
      [`container-${e.fluid}`]: typeof e.fluid == "string",
      [`gx-${e.gutterX}`]: e.gutterX !== null,
      [`gy-${e.gutterY}`]: e.gutterY !== null
    }));
    return me(() => {
      e.toast;
    }), e.toast && (n = Da({ container: l, root: e.toast.root }), a({})), () => {
      var f;
      const d = [];
      return n == null || n.containerPositions.value.forEach((v) => {
        d.push(Q(Ct, { key: v, instance: n, position: v }));
      }), Q(e.tag, { class: [r.value, e.position], ref: l }, [
        ...d,
        (f = t.default) == null ? void 0 : f.call(t)
      ]);
    };
  },
  methods: {}
}), co = { class: "visually-hidden" }, fo = ["aria-labelledby", "role"], qa = /* @__PURE__ */ x({
  __name: "BDropdown",
  props: {
    id: null,
    menuClass: null,
    size: null,
    splitClass: null,
    splitVariant: null,
    text: null,
    toggleClass: null,
    autoClose: { type: [Boolean, String], default: !0 },
    block: { default: !1 },
    boundary: { default: "clippingParents" },
    dark: { default: !1 },
    disabled: { default: !1 },
    isNav: { default: !1 },
    dropup: { default: !1 },
    dropright: { default: !1 },
    dropleft: { default: !1 },
    noFlip: { default: !1 },
    offset: { default: 0 },
    popperOpts: { default: () => ({}) },
    right: { default: !1 },
    role: { default: "menu" },
    split: { default: !1 },
    splitButtonType: { default: "button" },
    splitHref: { default: void 0 },
    noCaret: { default: !1 },
    toggleText: { default: "Toggle dropdown" },
    variant: { default: "secondary" }
  },
  emits: ["show", "shown", "hide", "hidden", "click", "toggle"],
  setup(e, { expose: t, emit: a }) {
    const l = e, n = i(o(l, "block")), r = i(o(l, "dark")), d = i(o(l, "disabled")), f = i(o(l, "dropup")), v = i(o(l, "dropright")), g = i(o(l, "isNav")), m = i(o(l, "dropleft")), y = i(o(l, "right")), p = i(o(l, "split")), T = i(o(l, "noCaret")), V = M(), h = M(), k = M(), $ = ge(o(l, "id"), "dropdown");
    fe(V, "show.bs.dropdown", () => a("show")), fe(V, "shown.bs.dropdown", () => a("shown")), fe(V, "hide.bs.dropdown", () => a("hide")), fe(V, "hidden.bs.dropdown", () => a("hidden"));
    const O = (A) => {
      p.value && a("click", A);
    }, N = u(() => ({
      "d-grid": n.value,
      "d-flex": n.value && p.value
    })), w = u(() => ({
      "nav-link": g.value,
      "dropdown-toggle": !p.value,
      "dropdown-toggle-no-caret": T.value && !p.value,
      "w-100": p.value && n.value
    })), C = u(() => ({
      "dropdown-menu-dark": r.value,
      "dropdown-menu-end": y.value
    })), _ = u(() => ({
      "data-bs-toggle": p.value ? void 0 : "dropdown",
      "aria-expanded": p.value ? void 0 : !1,
      ref: p.value ? void 0 : h,
      href: p.value ? l.splitHref : void 0
    })), W = u(() => ({
      ref: p.value ? h : void 0
    })), I = () => {
      var A;
      (A = k.value) == null || A.hide();
    };
    return me(() => {
      var A;
      k.value = new gl((A = h.value) == null ? void 0 : A.$el, {
        autoClose: l.autoClose,
        boundary: l.boundary,
        offset: l.offset ? l.offset.toString() : "",
        reference: l.offset || p.value ? "parent" : "toggle",
        popperConfig: (L) => {
          const J = {
            placement: "bottom-start",
            modifiers: l.noFlip ? [
              {
                name: "flip",
                options: {
                  fallbackPlacements: []
                }
              }
            ] : []
          };
          return f.value ? J.placement = y.value ? "top-end" : "top-start" : v.value ? J.placement = "right-start" : m.value ? J.placement = "left-start" : y.value && (J.placement = "bottom-end"), $t(L, $t(J, l.popperOpts));
        }
      });
    }), t({
      hide: I
    }), (A, L) => (c(), b("div", {
      ref_key: "parent",
      ref: V,
      class: F([s(N), "btn-group"])
    }, [
      Se(We, U({
        id: s($),
        variant: e.splitVariant || e.variant,
        size: e.size,
        class: [s(w), s(p) ? e.splitClass : e.toggleClass],
        disabled: s(d),
        type: e.splitButtonType
      }, s(_), { onClick: O }), {
        default: E(() => [
          B(A.$slots, "button-content", {}, () => [
            Z(D(e.text), 1)
          ])
        ]),
        _: 3
      }, 16, ["id", "variant", "size", "class", "disabled", "type"]),
      s(p) ? (c(), z(We, U({
        key: 0,
        variant: e.variant,
        size: e.size,
        disabled: s(d)
      }, s(W), {
        class: [e.toggleClass, "dropdown-toggle-split dropdown-toggle"],
        "data-bs-toggle": "dropdown",
        "aria-expanded": "false",
        onClick: L[0] || (L[0] = (J) => a("toggle"))
      }), {
        default: E(() => [
          q("span", co, [
            B(A.$slots, "toggle-text", {}, () => [
              Z(D(e.toggleText), 1)
            ])
          ])
        ]),
        _: 3
      }, 16, ["variant", "size", "disabled", "class"])) : R("", !0),
      q("ul", {
        class: F(["dropdown-menu", [e.menuClass, s(C)]]),
        "aria-labelledby": s($),
        role: e.role
      }, [
        B(A.$slots, "default")
      ], 10, fo)
    ], 2));
  }
}), vo = { role: "presentation" }, bo = /* @__PURE__ */ x({
  __name: "BDropdownDivider",
  props: {
    tag: { default: "hr" }
  },
  setup(e) {
    return (t, a) => (c(), b("li", vo, [
      (c(), z(K(e.tag), {
        class: "dropdown-divider",
        role: "separator",
        "aria-orientation": "horizontal"
      }))
    ]));
  }
}), mo = {}, go = { role: "presentation" }, po = { class: "px-4 py-3" };
function ho(e, t) {
  return c(), b("li", go, [
    q("form", po, [
      B(e.$slots, "default")
    ])
  ]);
}
const yo = /* @__PURE__ */ he(mo, [["render", ho]]), Bo = { role: "presentation" }, $o = ["id", "aria-describedby"], ko = {
  inheritAttrs: !1
}, So = /* @__PURE__ */ x({
  ...ko,
  __name: "BDropdownGroup",
  props: {
    id: null,
    ariaDescribedby: null,
    header: null,
    headerClass: { default: void 0 },
    headerTag: { default: "header" },
    headerVariant: null
  },
  setup(e) {
    const t = e, a = u(
      () => t.id ? `${t.id}_group_dd_header` : void 0
    ), l = u(
      () => t.headerTag === "header" ? void 0 : "heading"
    ), n = u(() => ({
      [`text-${t.headerVariant}`]: t.headerVariant !== void 0
    }));
    return (r, d) => (c(), b("li", Bo, [
      (c(), z(K(e.headerTag), {
        id: s(a),
        class: F(["dropdown-header", [s(n), e.headerClass]]),
        role: s(l)
      }, {
        default: E(() => [
          B(r.$slots, "header", {}, () => [
            Z(D(e.header), 1)
          ])
        ]),
        _: 3
      }, 8, ["id", "class", "role"])),
      q("ul", U({
        id: e.id,
        role: "group",
        class: "list-unstyled"
      }, r.$attrs, {
        "aria-describedby": e.ariaDescribedby || s(a)
      }), [
        B(r.$slots, "default")
      ], 16, $o)
    ]));
  }
}), Co = {}, To = { class: "dropdown-header" };
function wo(e, t) {
  return c(), b("li", null, [
    q("h6", To, [
      B(e.$slots, "default")
    ])
  ]);
}
const Vo = /* @__PURE__ */ he(Co, [["render", wo]]), _o = {
  inheritAttrs: !1
}, Ao = /* @__PURE__ */ x({
  ..._o,
  __name: "BDropdownItem",
  props: {
    href: null,
    linkClass: null,
    active: { default: !1 },
    disabled: { default: !1 },
    rel: { default: void 0 },
    target: { default: "_self" },
    variant: null
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const a = e, l = i(o(a, "active")), n = i(o(a, "disabled")), r = aa(), d = u(() => ({
      active: l.value,
      disabled: n.value,
      [`text-${a.variant}`]: a.variant !== void 0
    })), f = u(
      () => a.href ? "a" : r.to ? ke : "button"
    ), v = u(() => ({
      disabled: n.value,
      "aria-current": l.value ? "true" : null,
      href: f.value === "a" ? a.href : null,
      rel: a.rel,
      type: f.value === "button" ? "button" : null,
      target: a.target,
      ...r.to ? { activeClass: "active", ...r } : {}
    })), g = (m) => t("click", m);
    return (m, y) => (c(), b("li", {
      role: "presentation",
      class: F(m.$attrs.class)
    }, [
      (c(), z(K(s(f)), U({
        class: ["dropdown-item", [s(d), e.linkClass]]
      }, s(v), { onClick: g }), {
        default: E(() => [
          B(m.$slots, "default")
        ]),
        _: 3
      }, 16, ["class"]))
    ], 2));
  }
}), xo = {
  inheritAttrs: !1
}, Io = /* @__PURE__ */ x({
  ...xo,
  __name: "BDropdownItemButton",
  props: {
    buttonClass: null,
    active: { default: !1 },
    activeClass: { default: "active" },
    disabled: { default: !1 },
    variant: null
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const a = e, l = i(o(a, "active")), n = i(o(a, "disabled")), r = u(() => ({
      [a.activeClass]: l.value,
      disabled: n.value,
      [`text-${a.variant}`]: a.variant !== void 0
    })), d = u(() => ({
      disabled: n.value
    })), f = (v) => t("click", v);
    return (v, g) => (c(), b("li", {
      role: "presentation",
      class: F(v.$attrs.class)
    }, [
      q("button", U({
        role: "menu",
        type: "button",
        class: ["dropdown-item", [s(r), e.buttonClass]]
      }, s(d), { onClick: f }), [
        B(v.$slots, "default")
      ], 16)
    ], 2));
  }
}), Fo = { role: "presentation" }, Oo = { class: "px-4 py-1 mb-0 text-muted" }, zo = /* @__PURE__ */ x({
  __name: "BDropdownText",
  props: {
    text: { default: "" }
  },
  setup(e) {
    return (t, a) => (c(), b("li", Fo, [
      q("p", Oo, [
        B(t.$slots, "default", {}, () => [
          Z(D(e.text), 1)
        ])
      ])
    ]));
  }
}), Po = ["id", "novalidate", "onSubmit"], Ra = /* @__PURE__ */ x({
  __name: "BForm",
  props: {
    id: null,
    floating: { default: !1 },
    novalidate: { default: !1 },
    validated: { default: !1 }
  },
  emits: ["submit"],
  setup(e, { emit: t }) {
    const a = e, l = i(o(a, "floating")), n = i(o(a, "novalidate")), r = i(o(a, "validated")), d = u(() => ({
      "form-floating": l.value,
      "was-validated": r.value
    })), f = (v) => t("submit", v);
    return (v, g) => (c(), b("form", {
      id: e.id,
      novalidate: s(n),
      class: F(s(d)),
      onSubmit: nt(f, ["prevent"])
    }, [
      B(v.$slots, "default")
    ], 42, Po));
  }
}), No = { class: "form-floating" }, Lo = ["for"], Eo = /* @__PURE__ */ x({
  __name: "BFormFloatingLabel",
  props: {
    labelFor: null,
    label: null,
    text: null
  },
  setup(e) {
    return (t, a) => (c(), b("div", No, [
      B(t.$slots, "default", {}, () => [
        Z(D(e.text), 1)
      ]),
      q("label", { for: e.labelFor }, [
        B(t.$slots, "label", {}, () => [
          Z(D(e.label), 1)
        ])
      ], 8, Lo)
    ]));
  }
}), wt = /* @__PURE__ */ x({
  __name: "BFormInvalidFeedback",
  props: {
    ariaLive: null,
    forceShow: { default: !1 },
    id: null,
    text: null,
    role: null,
    state: { default: void 0 },
    tag: { default: "div" },
    tooltip: { default: !1 }
  },
  setup(e) {
    const t = e, a = i(o(t, "forceShow")), l = i(o(t, "state")), n = i(o(t, "tooltip")), r = u(
      () => a.value === !0 || l.value === !1
    ), d = u(() => ({
      "d-block": r.value,
      "invalid-feedback": !n.value,
      "invalid-tooltip": n.value
    })), f = u(() => ({
      id: t.id,
      role: t.role,
      "aria-live": t.ariaLive,
      "aria-atomic": t.ariaLive ? "true" : void 0
    }));
    return (v, g) => (c(), z(K(e.tag), U({ class: s(d) }, s(f)), {
      default: E(() => [
        B(v.$slots, "default", {}, () => [
          Z(D(e.text), 1)
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Qe = /* @__PURE__ */ x({
  __name: "BFormRow",
  props: {
    tag: { default: "div" }
  },
  setup(e) {
    return (t, a) => (c(), z(K(e.tag), { class: "row d-flex flex-wrap" }, {
      default: E(() => [
        B(t.$slots, "default")
      ]),
      _: 3
    }));
  }
}), Vt = /* @__PURE__ */ x({
  __name: "BFormText",
  props: {
    id: null,
    inline: { default: !1 },
    tag: { default: "small" },
    text: null,
    textVariant: { default: "muted" }
  },
  setup(e) {
    const t = e, a = i(o(t, "inline")), l = u(() => ({
      "form-text": !a.value,
      [`text-${t.textVariant}`]: !!t.textVariant
    })), n = u(() => ({
      id: t.id
    }));
    return (r, d) => (c(), z(K(e.tag), U({ class: s(l) }, s(n)), {
      default: E(() => [
        B(r.$slots, "default", {}, () => [
          Z(D(e.text), 1)
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), _t = /* @__PURE__ */ x({
  __name: "BFormValidFeedback",
  props: {
    ariaLive: null,
    forceShow: { default: !1 },
    id: null,
    role: null,
    text: null,
    state: { default: void 0 },
    tag: { default: "div" },
    tooltip: { default: !1 }
  },
  setup(e) {
    const t = e, a = i(o(t, "forceShow")), l = i(o(t, "state")), n = i(o(t, "tooltip")), r = u(
      () => a.value === !0 || l.value === !0
    ), d = u(() => ({
      "d-block": r.value,
      "valid-feedback": !n.value,
      "valid-tooltip": n.value
    })), f = u(() => ({
      id: t.id || null,
      role: t.role || null,
      "aria-live": t.ariaLive || null,
      "aria-atomic": t.ariaLive ? "true" : null
    }));
    return (v, g) => (c(), z(K(e.tag), U({ class: s(d) }, s(f)), {
      default: E(() => [
        B(v.$slots, "default", {}, () => [
          Z(D(e.text), 1)
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Ho = ["id", "disabled", "required", "name", "form", "aria-label", "aria-labelledby", "aria-required", "value", "indeterminate"], Do = ["for"], qo = {
  inheritAttrs: !1
}, ja = /* @__PURE__ */ x({
  ...qo,
  __name: "BFormCheckbox",
  props: {
    ariaLabel: null,
    ariaLabelledBy: null,
    form: null,
    indeterminate: null,
    name: null,
    id: { default: void 0 },
    autofocus: { default: !1 },
    plain: { default: !1 },
    button: { default: !1 },
    switch: { default: !1 },
    disabled: { default: !1 },
    buttonVariant: { default: "secondary" },
    inline: { default: !1 },
    required: { default: void 0 },
    size: { default: "md" },
    state: { default: void 0 },
    uncheckedValue: { type: [Array, Set, Boolean, String, Object, Number], default: !1 },
    value: { type: [Array, Set, Boolean, String, Object, Number], default: !0 },
    modelValue: { type: [Array, Set, Boolean, String, Object, Number], default: void 0 }
  },
  emits: ["update:modelValue", "input", "change"],
  setup(e, { emit: t }) {
    const a = e, l = i(
      o(a, "indeterminate")
    ), n = i(o(a, "autofocus")), r = i(o(a, "plain")), d = i(o(a, "button")), f = i(o(a, "switch")), v = i(o(a, "disabled")), g = i(o(a, "inline")), m = i(o(a, "required")), y = i(o(a, "state")), p = ge(o(a, "id"), "form-check"), T = M(null), V = M(!1), h = u({
      get: () => a.uncheckedValue ? Array.isArray(a.modelValue) ? a.modelValue.indexOf(a.value) > -1 : a.modelValue === a.value : a.modelValue,
      set: (C) => {
        let _ = C;
        Array.isArray(a.modelValue) ? a.uncheckedValue && (_ = a.modelValue, C ? (_.indexOf(a.uncheckedValue) > -1 && _.splice(_.indexOf(a.uncheckedValue), 1), _.push(a.value)) : (_.indexOf(a.value) > -1 && _.splice(_.indexOf(a.value), 1), _.push(a.uncheckedValue))) : _ = C ? a.value : a.uncheckedValue, t("input", _), t("update:modelValue", _), t("change", _);
      }
    }), k = u(() => Array.isArray(a.modelValue) ? a.modelValue.indexOf(a.value) > -1 : JSON.stringify(a.modelValue) === JSON.stringify(a.value)), $ = Ae({
      plain: o(r, "value"),
      button: o(d, "value"),
      inline: o(g, "value"),
      switch: o(f, "value"),
      size: o(a, "size"),
      state: o(y, "value"),
      buttonVariant: o(a, "buttonVariant")
    }), O = ma($), N = ga($), w = pa($);
    return me(() => {
      n.value && T.value.focus();
    }), (C, _) => (c(), b("div", {
      class: F(s(O))
    }, [
      Xe(q("input", U({ id: s(p) }, C.$attrs, {
        ref_key: "input",
        ref: T,
        "onUpdate:modelValue": _[0] || (_[0] = (W) => Ke(h) ? h.value = W : null),
        class: s(N),
        type: "checkbox",
        disabled: s(v),
        required: !!e.name && !!s(m),
        name: e.name,
        form: e.form,
        "aria-label": e.ariaLabel,
        "aria-labelledby": e.ariaLabelledBy,
        "aria-required": e.name && s(m) ? "true" : void 0,
        value: e.value,
        indeterminate: s(l),
        onFocus: _[1] || (_[1] = (W) => V.value = !0),
        onBlur: _[2] || (_[2] = (W) => V.value = !1)
      }), null, 16, Ho), [
        [rl, s(h)]
      ]),
      C.$slots.default || !s(r) ? (c(), b("label", {
        key: 0,
        for: s(p),
        class: F([s(w), { active: s(k), focus: V.value }])
      }, [
        B(C.$slots, "default")
      ], 10, Do)) : R("", !0)
    ], 2));
  }
}), Ro = ["id"], jo = ["innerHTML"], Mo = ["textContent"], Go = /* @__PURE__ */ x({
  __name: "BFormCheckboxGroup",
  props: {
    id: null,
    form: null,
    modelValue: { default: () => [] },
    ariaInvalid: { default: void 0 },
    autofocus: { default: !1 },
    buttonVariant: { default: "secondary" },
    buttons: { default: !1 },
    disabled: { default: !1 },
    disabledField: { default: "disabled" },
    htmlField: { default: "html" },
    name: null,
    options: { default: () => [] },
    plain: { default: !1 },
    required: { default: !1 },
    size: null,
    stacked: { default: !1 },
    state: { default: void 0 },
    switches: { default: !1 },
    textField: { default: "text" },
    validated: { default: !1 },
    valueField: { default: "value" }
  },
  emits: ["input", "update:modelValue", "change"],
  setup(e, { emit: t }) {
    const a = e;
    i(o(a, "autofocus"));
    const l = i(o(a, "buttons")), n = i(o(a, "disabled"));
    i(o(a, "plain"));
    const r = i(o(a, "required")), d = i(o(a, "stacked")), f = i(o(a, "state")), v = i(o(a, "switches")), g = i(o(a, "validated")), m = Le(), y = "BFormCheckbox", p = ge(o(a, "id"), "checkbox"), T = ge(o(a, "name"), "checkbox"), V = u({
      get: () => a.modelValue,
      set: (N) => {
        if (JSON.stringify(N) === JSON.stringify(a.modelValue))
          return;
        const w = a.options.filter(
          (C) => N.map((_) => JSON.stringify(_)).includes(JSON.stringify(typeof C == "string" ? C : C[a.valueField]))
        ).map((C) => typeof C == "string" ? C : C[a.valueField]);
        t("input", w), t("update:modelValue", w), t("change", w);
      }
    }), h = u(
      () => (m.first ? at(m.first(), y, n.value) : []).concat(a.options.map((N) => Ba(N, a))).concat(m.default ? at(m.default(), y, n.value) : []).map((N, w) => $a(N, w, a, T, p)).map((N) => ({
        ...N,
        props: {
          switch: v.value,
          ...N.props
        }
      }))
    ), k = Ae({
      required: o(r, "value"),
      ariaInvalid: o(a, "ariaInvalid"),
      state: o(f, "value"),
      validated: o(g, "value"),
      buttons: o(l, "value"),
      stacked: o(d, "value"),
      size: o(a, "size")
    }), $ = ha(k), O = ya(k);
    return (N, w) => (c(), b("div", U(s($), {
      id: s(p),
      role: "group",
      class: [s(O), "bv-no-focus-ring"],
      tabindex: "-1"
    }), [
      (c(!0), b(oe, null, ve(s(h), (C, _) => (c(), z(ja, U({
        key: _,
        modelValue: s(V),
        "onUpdate:modelValue": w[0] || (w[0] = (W) => Ke(V) ? V.value = W : null)
      }, C.props), {
        default: E(() => [
          C.html ? (c(), b("span", {
            key: 0,
            innerHTML: C.html
          }, null, 8, jo)) : (c(), b("span", {
            key: 1,
            textContent: D(C.text)
          }, null, 8, Mo))
        ]),
        _: 2
      }, 1040, ["modelValue"]))), 128))
    ], 16, Ro));
  }
}), Ma = ["input", "select", "textarea"], Uo = Ma.map((e) => `${e}:not([disabled])`).join(), Wo = [...Ma, "a", "button", "label"], Xo = "label", Ko = "invalid-feedback", Jo = "valid-feedback", Yo = "description", Zo = "default", Qo = x({
  components: { BCol: Ge, BFormInvalidFeedback: wt, BFormRow: Qe, BFormText: Vt, BFormValidFeedback: _t },
  props: {
    contentCols: { type: [Boolean, String, Number], required: !1 },
    contentColsLg: { type: [Boolean, String, Number], required: !1 },
    contentColsMd: { type: [Boolean, String, Number], required: !1 },
    contentColsSm: { type: [Boolean, String, Number], required: !1 },
    contentColsXl: { type: [Boolean, String, Number], required: !1 },
    description: { type: [String], required: !1 },
    disabled: { type: [Boolean, String], default: !1 },
    feedbackAriaLive: { type: String, default: "assertive" },
    id: { type: String, required: !1 },
    invalidFeedback: { type: String, required: !1 },
    label: { type: String, required: !1 },
    labelAlign: { type: [Boolean, String, Number], required: !1 },
    labelAlignLg: { type: [Boolean, String, Number], required: !1 },
    labelAlignMd: { type: [Boolean, String, Number], required: !1 },
    labelAlignSm: { type: [Boolean, String, Number], required: !1 },
    labelAlignXl: { type: [Boolean, String, Number], required: !1 },
    labelClass: { type: [Array, Object, String], required: !1 },
    labelCols: { type: [Boolean, String, Number], required: !1 },
    labelColsLg: { type: [Boolean, String, Number], required: !1 },
    labelColsMd: { type: [Boolean, String, Number], required: !1 },
    labelColsSm: { type: [Boolean, String, Number], required: !1 },
    labelColsXl: { type: [Boolean, String, Number], required: !1 },
    labelFor: { type: String, required: !1 },
    labelSize: { type: String, required: !1 },
    labelSrOnly: { type: [Boolean, String], default: !1 },
    state: { type: [Boolean, String], default: null },
    tooltip: { type: [Boolean, String], default: !1 },
    validFeedback: { type: String, required: !1 },
    validated: { type: [Boolean, String], default: !1 },
    floating: { type: [Boolean, String], default: !1 }
  },
  setup(e, { attrs: t }) {
    const a = i(o(e, "disabled")), l = i(o(e, "labelSrOnly")), n = i(o(e, "state")), r = i(o(e, "tooltip")), d = i(o(e, "validated")), f = i(o(e, "floating")), v = null, g = ["xs", "sm", "md", "lg", "xl"], m = (_, W) => g.reduce((I, A) => {
      const L = _[Rt(A, `${W}Align`)] || null;
      return L && I.push(["text", A, L].filter((J) => J).join("-")), I;
    }, []), y = (_, W) => g.reduce((I, A) => {
      let L = _[Rt(A, `${W}Cols`)];
      return L = L === "" ? !0 : L || !1, typeof L != "boolean" && L !== "auto" && (L = Dl(L, 0), L = L > 0 ? L : !1), L && (I[A || (typeof L == "boolean" ? "col" : "cols")] = L), I;
    }, {}), p = M(), T = (_, W = null) => {
      if (_l && e.labelFor) {
        const I = Pl(`#${wl(e.labelFor)}`, p);
        if (I) {
          const A = "aria-describedby", L = (_ || "").split(Ye), J = (W || "").split(Ye), le = (da(I, A) || "").split(Ye).filter((ae) => !J.includes(ae)).concat(L).filter((ae, X, ue) => ue.indexOf(ae) === X).filter((ae) => ae).join(" ").trim();
          le ? Ll(I, A, le) : El(I, A);
        }
      }
    }, V = u(() => y(e, "content")), h = u(() => m(e, "label")), k = u(() => y(e, "label")), $ = u(
      () => Object.keys(V.value).length > 0 || Object.keys(k.value).length > 0
    ), O = u(
      () => typeof n.value == "boolean" ? n.value : null
    ), N = u(() => {
      const _ = O.value;
      return _ === !0 ? "is-valid" : _ === !1 ? "is-invalid" : null;
    }), w = u(
      () => rt(t.ariaInvalid, n.value)
    );
    return ie(
      () => v,
      (_, W) => {
        _ !== W && T(_, W);
      }
    ), me(() => {
      Fe(() => {
        T(v);
      });
    }), {
      disabledBoolean: a,
      labelSrOnlyBoolean: l,
      stateBoolean: n,
      tooltipBoolean: r,
      validatedBoolean: d,
      floatingBoolean: f,
      ariaDescribedby: v,
      computedAriaInvalid: w,
      contentColProps: V,
      isHorizontal: $,
      labelAlignClasses: h,
      labelColProps: k,
      onLegendClick: (_) => {
        if (e.labelFor)
          return;
        const { target: W } = _, I = W ? W.tagName : "";
        if (Wo.indexOf(I) !== -1)
          return;
        const A = Nl(Uo, p).filter(zl);
        A.length === 1 && Fl(A[0]);
      },
      stateClass: N
    };
  },
  render() {
    const e = this.$props, t = this.$slots, a = ge(), l = !e.labelFor;
    let n = null;
    const r = $e(Xo, {}, t) || e.label, d = r ? _e("_BV_label_") : null;
    if (r || this.isHorizontal) {
      const w = l ? "legend" : "label";
      if (this.labelSrOnlyBoolean)
        r && (n = Q(
          w,
          {
            class: "visually-hidden",
            id: d,
            for: e.labelFor || null
          },
          r
        )), this.isHorizontal ? n = Q(Ge, this.labelColProps, { default: () => n }) : n = Q("div", {}, [n]);
      else {
        const C = {
          onClick: l ? this.onLegendClick : null,
          ...this.isHorizontal ? this.labelColProps : {},
          tag: this.isHorizontal ? w : null,
          id: d,
          for: e.labelFor || null,
          tabIndex: l ? "-1" : null,
          class: [
            this.isHorizontal ? "col-form-label" : "form-label",
            {
              "bv-no-focus-ring": l,
              "col-form-label": this.isHorizontal || l,
              "pt-0": !this.isHorizontal && l,
              "d-block": !this.isHorizontal && !l,
              [`col-form-label-${e.labelSize}`]: !!e.labelSize
            },
            this.labelAlignClasses,
            e.labelClass
          ]
        };
        this.isHorizontal ? n = Q(Ge, C, { default: () => r }) : n = Q(w, C, r);
      }
    }
    let f = null;
    const v = $e(Ko, {}, t) || this.invalidFeedback, g = v ? _e("_BV_feedback_invalid_") : void 0;
    v && (f = Q(
      wt,
      {
        ariaLive: e.feedbackAriaLive,
        id: g,
        state: this.stateBoolean,
        tooltip: this.tooltipBoolean
      },
      { default: () => v }
    ));
    let m = null;
    const y = $e(Jo, {}, t) || this.validFeedback, p = y ? _e("_BV_feedback_valid_") : void 0;
    y && (m = Q(
      _t,
      {
        ariaLive: e.feedbackAriaLive,
        id: p,
        state: this.stateBoolean,
        tooltip: this.tooltipBoolean
      },
      { default: () => y }
    ));
    let T = null;
    const V = $e(Yo, {}, t) || this.description, h = V ? _e("_BV_description_") : void 0;
    V && (T = Q(
      Vt,
      {
        id: h
      },
      { default: () => V }
    ));
    const k = this.ariaDescribedby = [
      h,
      this.stateBoolean === !1 ? g : null,
      this.stateBoolean === !0 ? p : null
    ].filter((w) => w).join(" ") || null, $ = [
      $e(Zo, { ariaDescribedby: k, descriptionId: h, id: a, labelId: d }, t) || "",
      f,
      m,
      T
    ];
    !this.isHorizontal && this.floatingBoolean && $.push(n);
    let O = Q(
      "div",
      {
        ref: "content",
        class: [
          {
            "form-floating": !this.isHorizontal && this.floatingBoolean
          }
        ]
      },
      $
    );
    this.isHorizontal && (O = Q(Ge, { ref: "content", ...this.contentColProps }, { default: () => $ }));
    const N = {
      class: [
        "mb-3",
        this.stateClass,
        {
          "was-validated": this.validatedBoolean
        }
      ],
      id: ge(o(e, "id")).value,
      disabled: l ? this.disabledBoolean : null,
      role: l ? null : "group",
      "aria-invalid": this.computedAriaInvalid,
      "aria-labelledby": l && this.isHorizontal ? d : null
    };
    return this.isHorizontal && !l ? Q(Qe, N, { default: () => [n, O] }) : Q(
      l ? "fieldset" : "div",
      N,
      this.isHorizontal && l ? [Q(Qe, {}, { default: () => [n, O] })] : this.isHorizontal || !this.floatingBoolean ? [n, O] : [O]
    );
  }
}), Yt = [
  "text",
  "number",
  "email",
  "password",
  "search",
  "url",
  "tel",
  "date",
  "time",
  "range",
  "color"
], es = x({
  props: {
    ...ka,
    max: { type: [String, Number], required: !1 },
    min: { type: [String, Number], required: !1 },
    step: { type: [String, Number], required: !1 },
    type: {
      type: String,
      default: "text",
      validator: (e) => Yt.includes(e)
    }
  },
  emits: ["update:modelValue", "change", "blur", "input"],
  setup(e, { emit: t }) {
    const a = u(() => {
      const p = e.type === "range", T = e.type === "color";
      return {
        "form-range": p,
        "form-control": T || !e.plaintext && !p,
        "form-control-color": T,
        "form-control-plaintext": e.plaintext && !p && !T,
        [`form-control-${e.size}`]: !!e.size,
        "is-valid": e.state === !0,
        "is-invalid": e.state === !1
      };
    }), l = u(
      () => Yt.includes(e.type) ? e.type : "text"
    ), { input: n, computedId: r, computedAriaInvalid: d, onInput: f, onChange: v, onBlur: g, focus: m, blur: y } = Sa(e, t);
    return {
      classes: a,
      localType: l,
      input: n,
      computedId: r,
      computedAriaInvalid: d,
      onInput: f,
      onChange: v,
      onBlur: g,
      focus: m,
      blur: y
    };
  }
}), ts = ["id", "name", "form", "type", "disabled", "placeholder", "required", "autocomplete", "readonly", "min", "max", "step", "list", "aria-required", "aria-invalid"];
function as(e, t, a, l, n, r) {
  return c(), b("input", U({
    id: e.computedId,
    ref: "input",
    class: e.classes,
    name: e.name || void 0,
    form: e.form || void 0,
    type: e.localType,
    disabled: e.disabled,
    placeholder: e.placeholder,
    required: e.required,
    autocomplete: e.autocomplete || void 0,
    readonly: e.readonly || e.plaintext,
    min: e.min,
    max: e.max,
    step: e.step,
    list: e.type !== "password" ? e.list : void 0,
    "aria-required": e.required ? "true" : void 0,
    "aria-invalid": e.computedAriaInvalid
  }, e.$attrs, {
    onInput: t[0] || (t[0] = (d) => e.onInput(d)),
    onChange: t[1] || (t[1] = (d) => e.onChange(d)),
    onBlur: t[2] || (t[2] = (d) => e.onBlur(d))
  }), null, 16, ts);
}
const ls = /* @__PURE__ */ he(es, [["render", as]]), ns = ["id", "disabled", "required", "name", "form", "aria-label", "aria-labelledby", "value", "aria-required"], os = ["for"], Ga = /* @__PURE__ */ x({
  __name: "BFormRadio",
  props: {
    ariaLabel: null,
    ariaLabelledBy: null,
    form: null,
    id: null,
    name: null,
    size: null,
    autofocus: { default: !1 },
    modelValue: { type: [Boolean, String, Array, Object, Number], default: void 0 },
    plain: { default: !1 },
    button: { default: !1 },
    switch: { default: !1 },
    disabled: { default: !1 },
    buttonVariant: { default: "secondary" },
    inline: { default: !1 },
    required: { default: !1 },
    state: { default: void 0 },
    value: { type: [String, Boolean, Object, Number], default: !0 }
  },
  emits: ["input", "change", "update:modelValue"],
  setup(e, { emit: t }) {
    const a = e, l = i(o(a, "autofocus")), n = i(o(a, "plain")), r = i(o(a, "button")), d = i(o(a, "switch")), f = i(o(a, "disabled")), v = i(o(a, "inline")), g = i(o(a, "required")), m = i(o(a, "state")), y = ge(o(a, "id"), "form-check"), p = M(null), T = M(!1), V = u({
      get: () => Array.isArray(a.modelValue) ? a.modelValue[0] : a.modelValue,
      set: (w) => {
        const C = w ? a.value : !1, _ = Array.isArray(a.modelValue) ? [C] : C;
        t("input", _), t("change", _), t("update:modelValue", _);
      }
    }), h = u(() => Array.isArray(a.modelValue) ? (a.modelValue || []).find((w) => w === a.value) : JSON.stringify(a.modelValue) === JSON.stringify(a.value)), k = Ae({
      plain: o(n, "value"),
      button: o(r, "value"),
      inline: o(v, "value"),
      switch: o(d, "value"),
      size: o(a, "size"),
      state: o(m, "value"),
      buttonVariant: o(a, "buttonVariant")
    }), $ = ma(k), O = ga(k), N = pa(k);
    return me(() => {
      l.value && p.value.focus();
    }), (w, C) => (c(), b("div", {
      class: F(s($))
    }, [
      Xe(q("input", U({ id: s(y) }, w.$attrs, {
        ref_key: "input",
        ref: p,
        "onUpdate:modelValue": C[0] || (C[0] = (_) => Ke(V) ? V.value = _ : null),
        class: s(O),
        type: "radio",
        disabled: s(f),
        required: !!e.name && !!s(g),
        name: e.name,
        form: e.form,
        "aria-label": e.ariaLabel,
        "aria-labelledby": e.ariaLabelledBy,
        value: e.value,
        "aria-required": e.name && s(g) ? !0 : void 0,
        onFocus: C[1] || (C[1] = (_) => T.value = !0),
        onBlur: C[2] || (C[2] = (_) => T.value = !1)
      }), null, 16, ns), [
        [ul, s(V)]
      ]),
      w.$slots.default || !s(n) ? (c(), b("label", {
        key: 0,
        for: s(y),
        class: F([s(N), { active: s(h), focus: T.value }])
      }, [
        B(w.$slots, "default")
      ], 10, os)) : R("", !0)
    ], 2));
  }
}), ss = ["id"], is = ["innerHTML"], rs = ["textContent"], us = /* @__PURE__ */ x({
  __name: "BFormRadioGroup",
  props: {
    size: null,
    form: null,
    id: null,
    name: null,
    modelValue: { type: [String, Boolean, Array, Object, Number], default: "" },
    ariaInvalid: { default: void 0 },
    autofocus: { default: !1 },
    buttonVariant: { default: "secondary" },
    buttons: { default: !1 },
    disabled: { default: !1 },
    disabledField: { default: "disabled" },
    htmlField: { default: "html" },
    options: { default: () => [] },
    plain: { default: !1 },
    required: { default: !1 },
    stacked: { default: !1 },
    state: { default: void 0 },
    textField: { default: "text" },
    validated: { default: !1 },
    valueField: { default: "value" }
  },
  emits: ["input", "update:modelValue", "change"],
  setup(e, { emit: t }) {
    const a = e;
    i(o(a, "autofocus"));
    const l = i(o(a, "buttons")), n = i(o(a, "disabled"));
    i(o(a, "plain"));
    const r = i(o(a, "required")), d = i(o(a, "stacked")), f = i(o(a, "state")), v = i(o(a, "validated")), g = Le(), m = "BFormRadio", y = ge(o(a, "id"), "radio"), p = ge(o(a, "name"), "checkbox"), T = u({
      get: () => a.modelValue,
      set: (O) => {
        t("input", O), t("update:modelValue", O), t("change", O);
      }
    }), V = u(
      () => (g.first ? at(g.first(), m, n.value) : []).concat(a.options.map((O) => Ba(O, a))).concat(g.default ? at(g.default(), m, n.value) : []).map((O, N) => $a(O, N, a, p, y)).map((O) => ({
        ...O
      }))
    ), h = Ae({
      required: o(r, "value"),
      ariaInvalid: o(a, "ariaInvalid"),
      state: o(f, "value"),
      validated: o(v, "value"),
      buttons: o(l, "value"),
      stacked: o(d, "value"),
      size: o(a, "size")
    }), k = ha(h), $ = ya(h);
    return (O, N) => (c(), b("div", U(s(k), {
      id: s(y),
      role: "radiogroup",
      class: [s($), "bv-no-focus-ring"],
      tabindex: "-1"
    }), [
      (c(!0), b(oe, null, ve(s(V), (w, C) => (c(), z(Ga, U({
        key: C,
        modelValue: s(T),
        "onUpdate:modelValue": N[0] || (N[0] = (_) => Ke(T) ? T.value = _ : null)
      }, w.props), {
        default: E(() => [
          w.html ? (c(), b("span", {
            key: 0,
            innerHTML: w.html
          }, null, 8, is)) : (c(), b("span", {
            key: 1,
            textContent: D(w.text)
          }, null, 8, rs))
        ]),
        _: 2
      }, 1040, ["modelValue"]))), 128))
    ], 16, ss));
  }
}), ds = ["value", "disabled"], Nt = /* @__PURE__ */ x({
  __name: "BFormSelectOption",
  props: {
    value: null,
    disabled: { default: !1 }
  },
  setup(e) {
    const a = i(o(e, "disabled"));
    return (l, n) => (c(), b("option", {
      value: e.value,
      disabled: s(a)
    }, [
      B(l.$slots, "default")
    ], 8, ds));
  }
}), cs = ["label"], Ua = /* @__PURE__ */ x({
  __name: "BFormSelectOptionGroup",
  props: {
    label: null,
    disabledField: { default: "disabled" },
    htmlField: { default: "html" },
    options: { default: () => [] },
    textField: { default: "text" },
    valueField: { default: "value" }
  },
  setup(e) {
    const t = e, a = u(
      () => Ot(t.options, "BFormSelectOptionGroup", t)
    );
    return (l, n) => (c(), b("optgroup", { label: e.label }, [
      B(l.$slots, "first"),
      (c(!0), b(oe, null, ve(s(a), (r, d) => (c(), z(Nt, U({
        key: `option_${d}`,
        value: r.value,
        disabled: r.disabled
      }, l.$attrs, {
        innerHTML: r.html || r.text
      }), null, 16, ["value", "disabled", "innerHTML"]))), 128)),
      B(l.$slots, "default")
    ], 8, cs));
  }
}), fs = ["id", "name", "form", "multiple", "size", "disabled", "required", "aria-required", "aria-invalid"], vs = /* @__PURE__ */ x({
  __name: "BFormSelect",
  props: {
    ariaInvalid: { default: void 0 },
    autofocus: { default: !1 },
    disabled: { default: !1 },
    disabledField: { default: "disabled" },
    form: null,
    htmlField: { default: "html" },
    id: null,
    labelField: { default: "label" },
    multiple: { default: !1 },
    name: null,
    options: { default: () => [] },
    optionsField: { default: "options" },
    plain: { default: !1 },
    required: { default: !1 },
    selectSize: { default: 0 },
    size: null,
    state: { default: void 0 },
    textField: { default: "text" },
    valueField: { default: "value" },
    modelValue: { default: "" }
  },
  emits: ["input", "update:modelValue", "change"],
  setup(e, { expose: t, emit: a }) {
    const l = e, n = i(o(l, "autofocus")), r = i(o(l, "disabled")), d = i(o(l, "multiple")), f = i(o(l, "plain")), v = i(o(l, "required")), g = i(o(l, "state")), m = M(), y = ge(o(l, "id"), "input"), p = () => {
      Fe(() => {
        var w;
        n.value && ((w = m.value) == null || w.focus());
      });
    };
    me(p), xt(p);
    const T = u(() => ({
      "form-control": f.value,
      [`form-control-${l.size}`]: l.size && f.value,
      "form-select": !f.value,
      [`form-select-${l.size}`]: l.size && !f.value,
      "is-valid": g.value === !0,
      "is-invalid": g.value === !1
    })), V = u(() => {
      if (l.selectSize || f.value)
        return l.selectSize;
    }), h = u(
      () => rt(l.ariaInvalid, g.value)
    ), k = u(
      () => Ot(l.options, "BFormSelect", l)
    ), $ = u({
      get() {
        return l.modelValue;
      },
      set(w) {
        a("change", w), a("update:modelValue", w), a("input", w);
      }
    });
    return t({
      blur: () => {
        var w;
        r.value || (w = m.value) == null || w.blur();
      },
      focus: () => {
        var w;
        r.value || (w = m.value) == null || w.focus();
      }
    }), (w, C) => Xe((c(), b("select", U({
      id: s(y),
      ref_key: "input",
      ref: m
    }, w.$attrs, {
      "onUpdate:modelValue": C[0] || (C[0] = (_) => Ke($) ? $.value = _ : null),
      class: s(T),
      name: e.name,
      form: e.form || void 0,
      multiple: s(d) || void 0,
      size: s(V),
      disabled: s(r),
      required: s(v),
      "aria-required": s(v) ? !0 : void 0,
      "aria-invalid": s(h)
    }), [
      B(w.$slots, "first"),
      (c(!0), b(oe, null, ve(s(k), (_, W) => (c(), b(oe, null, [
        Array.isArray(_.options) ? (c(), z(Ua, {
          key: `option_${W}`,
          label: _.label,
          options: _.options
        }, null, 8, ["label", "options"])) : (c(), z(Nt, {
          key: `option2_${W}`,
          value: _.value,
          disabled: _.disabled,
          innerHTML: _.html || _.text
        }, null, 8, ["value", "disabled", "innerHTML"]))
      ], 64))), 256)),
      B(w.$slots, "default")
    ], 16, fs)), [
      [dl, s($)]
    ]);
  }
}), bs = ["id"], Wa = /* @__PURE__ */ x({
  __name: "BFormTag",
  props: {
    id: null,
    title: null,
    disabled: { default: !1 },
    noRemove: { default: !1 },
    pill: { default: !1 },
    removeLabel: { default: "Remove tag" },
    tag: { default: "span" },
    variant: { default: "secondary" }
  },
  emits: ["remove"],
  setup(e, { emit: t }) {
    const a = e, l = i(o(a, "disabled")), n = i(o(a, "noRemove")), r = i(o(a, "pill")), d = Le(), f = u(
      () => {
        var y, p, T;
        return (T = ((p = (y = d.default) == null ? void 0 : y.call(d)[0].children) == null ? void 0 : p.toString()) || a.title) != null ? T : "";
      }
    ), v = ge(o(a, "id")), g = u(() => `${v.value}taglabel__`), m = u(() => [
      `bg-${a.variant}`,
      {
        "text-dark": ["warning", "info", "light"].includes(a.variant),
        "rounded-pill": r.value,
        disabled: l.value
      }
    ]);
    return (y, p) => (c(), z(K(e.tag), {
      id: s(v),
      title: s(f),
      class: F(["badge b-form-tag d-inline-flex align-items-center mw-100", s(m)]),
      "aria-labelledby": s(g)
    }, {
      default: E(() => [
        q("span", {
          id: s(g),
          class: "b-form-tag-content flex-grow-1 text-truncate"
        }, [
          B(y.$slots, "default", {}, () => [
            Z(D(s(f)), 1)
          ])
        ], 8, bs),
        !s(l) && !s(n) ? (c(), z(Me, {
          key: 0,
          "aria-keyshortcuts": "Delete",
          type: "button",
          "aria-label": e.removeLabel,
          class: "b-form-tag-remove",
          white: !["warning", "info", "light"].includes(e.variant),
          "aria-describedby": s(g),
          "aria-controls": e.id,
          onClick: p[0] || (p[0] = (T) => t("remove", s(f)))
        }, null, 8, ["aria-label", "white", "aria-describedby", "aria-controls"])) : R("", !0)
      ]),
      _: 3
    }, 8, ["id", "title", "class", "aria-labelledby"]));
  }
}), ms = ["id"], gs = ["id", "for", "aria-live"], ps = ["id", "aria-live"], hs = ["id"], ys = ["aria-controls"], Bs = {
  role: "group",
  class: "d-flex"
}, $s = ["id", "disabled", "value", "type", "placeholder", "form", "required"], ks = ["disabled"], Ss = {
  "aria-live": "polite",
  "aria-atomic": "true"
}, Cs = {
  key: 0,
  class: "d-block invalid-feedback"
}, Ts = {
  key: 1,
  class: "form-text text-muted"
}, ws = {
  key: 2,
  class: "form-text text-muted"
}, Vs = ["name", "value"], _s = /* @__PURE__ */ x({
  __name: "BFormTags",
  props: {
    addButtonText: { default: "Add" },
    addButtonVariant: { default: "outline-secondary" },
    addOnChange: { default: !1 },
    autofocus: { default: !1 },
    disabled: { default: !1 },
    duplicateTagText: { default: "Duplicate tag(s)" },
    inputAttrs: null,
    inputClass: null,
    inputId: null,
    inputType: { default: "text" },
    invalidTagText: { default: "Invalid tag(s)" },
    form: null,
    limit: null,
    limitTagsText: { default: "Tag limit reached" },
    modelValue: { default: () => [] },
    name: null,
    noAddOnEnter: { default: !1 },
    noOuterFocus: { default: !1 },
    noTagRemove: { default: !1 },
    placeholder: { default: "Add tag..." },
    removeOnDelete: { default: !1 },
    required: { default: !1 },
    separator: null,
    state: { default: void 0 },
    size: null,
    tagClass: null,
    tagPills: { default: !1 },
    tagRemoveLabel: null,
    tagRemovedLabel: { default: "Tag removed" },
    tagValidator: { type: Function, default: () => !0 },
    tagVariant: { default: "secondary" }
  },
  emits: ["update:modelValue", "input", "tag-state", "focus", "focusin", "focusout", "blur"],
  setup(e, { emit: t }) {
    const a = e, l = i(o(a, "addOnChange")), n = i(o(a, "autofocus")), r = i(o(a, "disabled")), d = i(o(a, "noAddOnEnter")), f = i(o(a, "noOuterFocus")), v = i(o(a, "noTagRemove")), g = i(o(a, "removeOnDelete")), m = i(o(a, "required")), y = i(o(a, "state")), p = i(o(a, "tagPills")), T = M(null), V = ge(), h = u(() => a.inputId || `${V.value}input__`);
    me(() => {
      ae(), a.modelValue.length > 0 && (O.value = !0);
    }), xt(() => ae()), ie(
      () => a.modelValue,
      (G) => {
        k.value = G;
      }
    );
    const k = M(a.modelValue), $ = M(""), O = M(!1), N = M(!1), w = M(""), C = M([]), _ = M([]), W = M([]), I = u(() => ({
      [`form-control-${a.size}`]: a.size !== void 0,
      disabled: r.value,
      focus: N.value,
      "is-invalid": y.value === !1,
      "is-valid": y.value === !0
    })), A = u(() => k.value.includes($.value)), L = u(
      () => $.value === "" ? !1 : !a.tagValidator($.value)
    ), J = u(() => k.value.length === a.limit), le = u(() => !L.value && !A.value), ae = () => {
      var G;
      n.value && ((G = T.value) == null || G.focus());
    }, X = (G) => {
      if (r.value) {
        G.target.blur();
        return;
      }
      t("focusin", G);
    }, ue = (G) => {
      r.value || f.value || (N.value = !0, t("focus", G));
    }, se = (G) => {
      N.value = !1, t("blur", G);
    }, ee = (G) => {
      var j, be;
      const te = typeof G == "string" ? G : G.target.value;
      if (O.value = !1, ((j = a.separator) == null ? void 0 : j.includes(te.charAt(0))) && te.length > 0) {
        T.value && (T.value.value = "");
        return;
      }
      if ($.value = te, (be = a.separator) != null && be.includes(te.charAt(te.length - 1))) {
        re(te.slice(0, te.length - 1));
        return;
      }
      C.value = a.tagValidator(te) && !A.value ? [te] : [], _.value = a.tagValidator(te) ? [] : [te], W.value = A.value ? [te] : [], t("tag-state", C.value, _.value, W.value);
    }, Y = (G) => {
      l.value && (ee(G), A.value || re($.value));
    }, ye = (G) => {
      if (G.key === "Enter" && !d.value) {
        re($.value);
        return;
      }
      (G.key === "Backspace" || G.key === "Delete") && g.value && $.value === "" && O.value && k.value.length > 0 ? Be(k.value[k.value.length - 1]) : O.value = !0;
    }, re = (G) => {
      var j;
      if (G = (G || $.value).trim(), G === "" || A.value || !a.tagValidator(G) || a.limit && J.value)
        return;
      const te = [...a.modelValue, G];
      $.value = "", O.value = !0, t("update:modelValue", te), t("input", te), (j = T.value) == null || j.focus();
    }, Be = (G) => {
      var j;
      const te = k.value.indexOf((j = G == null ? void 0 : G.toString()) != null ? j : "");
      w.value = k.value.splice(te, 1).toString(), t("update:modelValue", k.value);
    }, we = u(() => {
      const {
        addButtonText: G,
        addButtonVariant: te,
        duplicateTagText: j,
        inputAttrs: be,
        form: Ve,
        inputType: ut,
        invalidTagText: dt,
        limitTagsText: ct,
        limit: ze,
        placeholder: S,
        separator: H,
        size: ne,
        tagClass: P,
        tagRemoveLabel: pe,
        tagVariant: de
      } = a;
      return {
        addButtonText: G,
        addButtonVariant: te,
        addTag: re,
        disableAddButton: le,
        disabled: r.value,
        duplicateTagText: j,
        duplicateTags: W,
        form: Ve,
        inputAttrs: {
          ...be,
          disabled: r.value,
          form: Ve,
          id: h,
          value: $
        },
        inputHandlers: {
          input: ee,
          keydown: ye,
          change: Y
        },
        inputId: h,
        inputType: ut,
        invalidTagText: dt,
        invalidTags: _,
        isDuplicate: A,
        isInvalid: L,
        isLimitReached: J,
        limitTagsText: ct,
        limit: ze,
        noTagRemove: v.value,
        placeholder: S,
        removeTag: Be,
        required: m.value,
        separator: H,
        size: ne,
        state: y.value,
        tagClass: P,
        tagPills: p.value,
        tagRemoveLabel: pe,
        tagVariant: de,
        tags: k
      };
    });
    return (G, te) => (c(), b("div", {
      id: s(V),
      class: F(["b-form-tags form-control h-auto", s(I)]),
      role: "group",
      tabindex: "-1",
      onFocusin: X,
      onFocusout: te[1] || (te[1] = (j) => t("focusout", j))
    }, [
      q("output", {
        id: `${s(V)}selected_tags__`,
        class: "visually-hidden",
        role: "status",
        for: s(h),
        "aria-live": N.value ? "polite" : "off",
        "aria-atomic": "true",
        "aria-relevant": "additions text"
      }, D(k.value.join(", ")), 9, gs),
      q("div", {
        id: `${s(V)}removed_tags__`,
        role: "status",
        "aria-live": N.value ? "assertive" : "off",
        "aria-atomic": "true",
        class: "visually-hidden"
      }, " (" + D(e.tagRemovedLabel) + ") " + D(w.value), 9, ps),
      B(G.$slots, "default", Ce(xe(s(we))), () => [
        q("ul", {
          id: `${s(V)}tag_list__`,
          class: "b-form-tags-list list-unstyled mb-0 d-flex flex-wrap align-items-center"
        }, [
          (c(!0), b(oe, null, ve(k.value, (j) => (c(), z(Wa, {
            key: j,
            class: F(e.tagClass),
            tag: "li",
            variant: e.tagVariant,
            pill: s(p),
            onRemove: Be
          }, {
            default: E(() => [
              Z(D(j), 1)
            ]),
            _: 2
          }, 1032, ["class", "variant", "pill"]))), 128)),
          q("li", {
            role: "none",
            "aria-live": "off",
            class: "b-from-tags-field flex-grow-1",
            "aria-controls": `${s(V)}tag_list__`
          }, [
            q("div", Bs, [
              q("input", U({
                id: s(h),
                ref_key: "input",
                ref: T,
                disabled: s(r),
                value: $.value,
                type: e.inputType,
                placeholder: e.placeholder,
                class: "b-form-tags-input w-100 flex-grow-1 p-0 m-0 bg-transparent border-0",
                style: { outline: "currentcolor none 0px", "min-width": "5rem" }
              }, e.inputAttrs, {
                form: e.form,
                required: s(m),
                onInput: ee,
                onChange: Y,
                onKeydown: ye,
                onFocus: ue,
                onBlur: se
              }), null, 16, $s),
              s(le) ? (c(), b("button", {
                key: 0,
                type: "button",
                class: F(["btn b-form-tags-button py-0", [
                  `btn-${e.addButtonVariant}`,
                  {
                    "disabled invisible": $.value.length === 0
                  },
                  e.inputClass
                ]]),
                style: { "font-size": "90%" },
                disabled: s(r) || $.value.length === 0 || s(J),
                onClick: te[0] || (te[0] = (j) => re($.value))
              }, [
                B(G.$slots, "add-button-text", {}, () => [
                  Z(D(e.addButtonText), 1)
                ])
              ], 10, ks)) : R("", !0)
            ])
          ], 8, ys)
        ], 8, hs),
        q("div", Ss, [
          s(L) ? (c(), b("div", Cs, D(e.invalidTagText) + ": " + D($.value), 1)) : R("", !0),
          s(A) ? (c(), b("small", Ts, D(e.duplicateTagText) + ": " + D($.value), 1)) : R("", !0),
          k.value.length === e.limit ? (c(), b("small", ws, "Tag limit reached")) : R("", !0)
        ])
      ]),
      e.name ? (c(!0), b(oe, { key: 0 }, ve(k.value, (j) => (c(), b("input", {
        key: j,
        type: "hidden",
        name: e.name,
        value: j
      }, null, 8, Vs))), 128)) : R("", !0)
    ], 42, ms));
  }
}), As = x({
  props: {
    ...ka,
    noResize: { type: [Boolean, String], default: !1 },
    rows: { type: [String, Number], required: !1, default: 2 },
    wrap: { type: String, default: "soft" }
  },
  emits: ["update:modelValue", "change", "blur", "input"],
  setup(e, { emit: t }) {
    const a = i(o(e, "noResize")), l = u(() => ({
      "form-control": !e.plaintext,
      "form-control-plaintext": e.plaintext,
      [`form-control-${e.size}`]: !!e.size,
      "is-valid": e.state === !0,
      "is-invalid": e.state === !1
    })), n = u(
      () => a.value ? { resize: "none" } : void 0
    ), { input: r, computedId: d, computedAriaInvalid: f, onInput: v, onChange: g, onBlur: m, focus: y, blur: p } = Sa(e, t);
    return {
      input: r,
      computedId: d,
      computedAriaInvalid: f,
      onInput: v,
      onChange: g,
      onBlur: m,
      focus: y,
      blur: p,
      classes: l,
      computedStyles: n
    };
  }
}), xs = ["id", "name", "form", "disabled", "placeholder", "required", "autocomplete", "readonly", "aria-required", "aria-invalid", "rows", "wrap"];
function Is(e, t, a, l, n, r) {
  return c(), b("textarea", U({
    id: e.computedId,
    ref: "input",
    class: e.classes,
    name: e.name || void 0,
    form: e.form || void 0,
    disabled: e.disabled,
    placeholder: e.placeholder,
    required: e.required,
    autocomplete: e.autocomplete || void 0,
    readonly: e.readonly || e.plaintext,
    "aria-required": e.required ? "true" : void 0,
    "aria-invalid": e.computedAriaInvalid,
    rows: e.rows,
    style: e.computedStyles,
    wrap: e.wrap || void 0
  }, e.$attrs, {
    onInput: t[0] || (t[0] = (d) => e.onInput(d)),
    onChange: t[1] || (t[1] = (d) => e.onChange(d)),
    onBlur: t[2] || (t[2] = (d) => e.onBlur(d))
  }), null, 16, xs);
}
const Fs = /* @__PURE__ */ he(As, [["render", Is]]), Os = {
  key: 0,
  class: "input-group-text"
}, zs = ["innerHTML"], Ps = { key: 1 }, Ns = {
  key: 0,
  class: "input-group-text"
}, Ls = ["innerHTML"], Es = { key: 1 }, Hs = /* @__PURE__ */ x({
  __name: "BInputGroup",
  props: {
    append: null,
    appendHtml: null,
    id: null,
    prepend: null,
    prependHtml: null,
    size: null,
    tag: { default: "div" }
  },
  setup(e) {
    const t = e, a = u(() => ({
      "input-group-sm": t.size === "sm",
      "input-group-lg": t.size === "lg"
    })), l = u(() => !!t.append || !!t.appendHtml), n = u(() => !!t.prepend || !!t.prependHtml);
    return (r, d) => (c(), z(K(e.tag), {
      id: e.id,
      class: F(["input-group", s(a)]),
      role: "group"
    }, {
      default: E(() => [
        B(r.$slots, "prepend", {}, () => [
          s(n) ? (c(), b("span", Os, [
            e.prependHtml ? (c(), b("span", {
              key: 0,
              innerHTML: e.prependHtml
            }, null, 8, zs)) : (c(), b("span", Ps, D(e.prepend), 1))
          ])) : R("", !0)
        ]),
        B(r.$slots, "default"),
        B(r.$slots, "append", {}, () => [
          s(l) ? (c(), b("span", Ns, [
            e.appendHtml ? (c(), b("span", {
              key: 0,
              innerHTML: e.appendHtml
            }, null, 8, Ls)) : (c(), b("span", Es, D(e.append), 1))
          ])) : R("", !0)
        ])
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), Xa = /* @__PURE__ */ x({
  __name: "BInputGroupText",
  props: {
    tag: { default: "div" },
    text: null
  },
  setup(e) {
    return (t, a) => (c(), z(K(e.tag), { class: "input-group-text" }, {
      default: E(() => [
        B(t.$slots, "default", {}, () => [
          Z(D(e.text), 1)
        ])
      ]),
      _: 3
    }));
  }
}), Lt = /* @__PURE__ */ x({
  __name: "BInputGroupAddon",
  props: {
    append: { default: !1 },
    id: null,
    isText: { default: !1 },
    tag: { default: "div" }
  },
  setup(e) {
    const t = e, a = i(o(t, "append")), l = i(o(t, "isText")), n = u(() => ({
      "input-group-append": a.value,
      "input-group-prepend": !a.value
    }));
    return (r, d) => (c(), z(K(e.tag), {
      id: e.id,
      class: F(["d-flex", s(n)])
    }, {
      default: E(() => [
        s(l) ? (c(), z(Xa, { key: 0 }, {
          default: E(() => [
            B(r.$slots, "default")
          ]),
          _: 3
        })) : B(r.$slots, "default", { key: 1 })
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), Ds = /* @__PURE__ */ x({
  __name: "BInputGroupAppend",
  props: {
    id: null,
    isText: { default: !1 },
    tag: { default: "div" }
  },
  setup(e) {
    const t = e, a = u(() => ({
      id: t.id,
      isText: t.isText,
      tag: t.tag,
      append: !0
    }));
    return (l, n) => (c(), z(Lt, Ce(xe(s(a))), {
      default: E(() => [
        B(l.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), qs = /* @__PURE__ */ x({
  __name: "BInputGroupPrepend",
  props: {
    id: null,
    isText: { default: !1 },
    tag: { default: "div" }
  },
  setup(e) {
    const t = e, a = u(() => ({
      id: t.id,
      isText: t.isText,
      tag: t.tag,
      append: !1
    }));
    return (l, n) => (c(), z(Lt, Ce(xe(s(a))), {
      default: E(() => [
        B(l.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Ka = Symbol(), Rs = /* @__PURE__ */ x({
  __name: "BListGroup",
  props: {
    flush: { default: !1 },
    horizontal: { type: [Boolean, String], default: !1 },
    numbered: { default: !1 },
    tag: { default: "div" }
  },
  setup(e) {
    const t = e, a = i(o(t, "flush")), l = i(o(t, "numbered")), n = u(() => {
      const d = a.value ? !1 : t.horizontal;
      return {
        "list-group-flush": a.value,
        "list-group-horizontal": d === !0,
        [`list-group-horizontal-${d}`]: typeof d == "string",
        "list-group-numbered": l.value
      };
    }), r = u(() => l.value === !0 ? "ol" : t.tag);
    return je(Ka, {
      numbered: l.value
    }), (d, f) => (c(), z(K(s(r)), {
      class: F(["list-group", s(n)])
    }, {
      default: E(() => [
        B(d.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), js = /* @__PURE__ */ x({
  __name: "BListGroupItem",
  props: {
    action: { default: !1 },
    active: { default: !1 },
    button: { default: !1 },
    disabled: { default: !1 },
    href: null,
    tag: { default: "div" },
    target: { default: "_self" },
    to: null,
    variant: null
  },
  setup(e) {
    const t = e, a = i(o(t, "action")), l = i(o(t, "active")), n = i(o(t, "button")), r = i(o(t, "disabled")), d = aa(), f = Ie(Ka, null), v = u(() => !n.value && (!!t.href || !!t.to)), g = u(
      () => f != null && f.numbered ? "li" : n.value ? "button" : v.value ? ke : t.tag
    ), m = u(() => {
      const p = a.value || v.value || n.value || ["a", "router-link", "button", "b-link"].includes(t.tag);
      return {
        [`list-group-item-${t.variant}`]: t.variant !== void 0,
        "list-group-item-action": p,
        active: l.value,
        disabled: r.value
      };
    }), y = u(() => {
      const p = {};
      return n.value && ((!d || !d.type) && (p.type = "button"), r.value && (p.disabled = !0)), p;
    });
    return (p, T) => (c(), z(K(s(g)), U({
      class: ["list-group-item", s(m)],
      "aria-current": s(l) ? !0 : null,
      "aria-disabled": s(r) ? !0 : null,
      target: s(v) ? e.target : null,
      href: s(n) ? null : e.href,
      to: s(n) ? null : e.to
    }, s(y)), {
      default: E(() => [
        B(p.$slots, "default")
      ]),
      _: 3
    }, 16, ["class", "aria-current", "aria-disabled", "target", "href", "to"]));
  }
}), Ms = ["id"], Gs = {
  inheritAttrs: !1
}, Us = /* @__PURE__ */ x({
  ...Gs,
  __name: "BModal",
  props: {
    bodyBgVariant: null,
    bodyClass: null,
    bodyTextVariant: null,
    busy: { default: !1 },
    lazy: { default: !1 },
    buttonSize: { default: "md" },
    cancelDisabled: { default: !1 },
    cancelTitle: { default: "Cancel" },
    cancelVariant: { default: "secondary" },
    centered: { default: !1 },
    contentClass: null,
    dialogClass: null,
    footerBgVariant: null,
    footerBorderVariant: null,
    footerClass: null,
    footerTextVariant: null,
    fullscreen: { type: [Boolean, String], default: !1 },
    headerBgVariant: null,
    headerBorderVariant: null,
    headerClass: null,
    headerCloseLabel: { default: "Close" },
    headerCloseWhite: { default: !1 },
    headerTextVariant: null,
    hideBackdrop: { default: !1 },
    hideFooter: { default: !1 },
    hideHeader: { default: !1 },
    hideHeaderClose: { default: !1 },
    id: null,
    modalClass: null,
    modelValue: { default: !1 },
    noCloseOnBackdrop: { default: !1 },
    noCloseOnEsc: { default: !1 },
    noFade: { default: !1 },
    noFocus: { default: !1 },
    okDisabled: { default: !1 },
    okOnly: { default: !1 },
    okTitle: { default: "Ok" },
    okVariant: { default: "primary" },
    scrollable: { default: !1 },
    show: { default: !1 },
    size: null,
    title: null,
    titleClass: null,
    titleSrOnly: { default: !1 },
    titleTag: { default: "h5" }
  },
  emits: ["update:modelValue", "show", "shown", "hide", "hidden", "hide-prevented", "ok", "cancel"],
  setup(e, { emit: t }) {
    const a = e, l = i(o(a, "busy")), n = i(o(a, "lazy")), r = i(o(a, "cancelDisabled")), d = i(o(a, "centered")), f = i(o(a, "headerCloseWhite")), v = i(o(a, "hideBackdrop")), g = i(o(a, "hideFooter")), m = i(o(a, "hideHeader")), y = i(o(a, "hideHeaderClose")), p = i(o(a, "modelValue")), T = i(o(a, "noCloseOnBackdrop")), V = i(o(a, "noCloseOnEsc")), h = i(o(a, "noFade")), k = i(o(a, "noFocus")), $ = i(o(a, "okDisabled")), O = i(o(a, "okOnly")), N = i(o(a, "scrollable")), w = i(o(a, "show")), C = i(o(a, "titleSrOnly")), _ = M(!1), W = ge(o(a, "id"), "modal"), I = M(), A = M(), L = u(() => [
      {
        fade: !h.value,
        show: w.value
      },
      a.modalClass
    ]), J = u(() => [
      {
        "modal-fullscreen": typeof a.fullscreen == "boolean" ? a.fullscreen : !1,
        [`modal-fullscreen-${a.fullscreen}-down`]: typeof a.fullscreen == "string" ? a.fullscreen : !1,
        [`modal-${a.size}`]: a.size,
        "modal-dialog-centered": d.value,
        "modal-dialog-scrollable": N.value
      },
      a.dialogClass
    ]), le = u(() => [
      {
        [`bg-${a.bodyBgVariant}`]: a.bodyBgVariant,
        [`text-${a.bodyTextVariant}`]: a.bodyTextVariant
      },
      a.bodyClass
    ]), ae = u(() => [
      {
        [`bg-${a.headerBgVariant}`]: a.headerBgVariant,
        [`border-${a.headerBorderVariant}`]: a.headerBorderVariant,
        [`text-${a.headerTextVariant}`]: a.headerTextVariant
      },
      a.headerClass
    ]), X = u(() => [
      {
        [`bg-${a.footerBgVariant}`]: a.footerBgVariant,
        [`border-${a.footerBorderVariant}`]: a.footerBorderVariant,
        [`text-${a.footerTextVariant}`]: a.footerTextVariant
      },
      a.footerClass
    ]), ue = u(() => [
      {
        ["visually-hidden"]: C.value
      },
      a.titleClass
    ]), se = u(() => r.value || l.value), ee = u(() => $.value || l.value);
    fe(I, "shown.bs.modal", (j) => Y(j)), fe(I, "hidden.bs.modal", (j) => ye(j)), fe(I, "show.bs.modal", (j) => re(j)), fe(I, "hide.bs.modal", (j) => Be(j));
    const Y = (j) => {
      t("shown", j), n.value === !0 && (_.value = !0), p.value === !1 && t("update:modelValue", !0), j.target.focus();
    }, ye = (j) => {
      t("hidden", j), n.value === !0 && (_.value = !1), p.value === !0 && t("update:modelValue", !1);
      const be = document.querySelector(".modal");
      be && be.focus();
    }, re = (j) => {
      t("show", j);
    }, Be = (j) => {
      t("hide", j);
    }, we = () => {
      p.value && t("update:modelValue", !0), te().show();
    }, G = () => {
      p.value && t("update:modelValue", !1), te().hide();
    }, te = () => (A.value !== void 0 || (A.value = new pl(I.value, {
      backdrop: !1,
      keyboard: !V.value,
      focus: !k.value
    })), A.value);
    return me(() => {
      p.value && te().show();
    }), ie(
      () => a.noCloseOnBackdrop,
      (j) => {
        te()._config.backdrop = a.hideBackdrop ? !1 : j ? "static" : !a.hideBackdrop;
      }
    ), ie(
      () => a.noCloseOnEsc,
      (j) => {
        te()._config.keyboard = !j;
      }
    ), ie(
      () => p.value,
      (j) => {
        Fe(() => {
          j ? we() : G();
        });
      }
    ), (j, be) => (c(), z(cl, { to: "body" }, [
      q("div", U({
        id: s(W),
        ref_key: "element",
        ref: I,
        class: ["modal", s(L)],
        tabindex: "-1"
      }, j.$attrs), [
        q("div", {
          class: F(["modal-dialog", s(J)])
        }, [
          !s(n) || s(n) && _.value || s(n) && s(p) === !0 ? (c(), b("div", {
            key: 0,
            class: F(["modal-content", e.contentClass])
          }, [
            s(m) ? R("", !0) : (c(), b("div", {
              key: 0,
              class: F(["modal-header", s(ae)])
            }, [
              (c(), z(K(e.titleTag), {
                class: F(["modal-title", s(ue)])
              }, {
                default: E(() => [
                  B(j.$slots, "title", {}, () => [
                    Z(D(e.title), 1)
                  ], !0)
                ]),
                _: 3
              }, 8, ["class"])),
              s(y) ? R("", !0) : (c(), b(oe, { key: 0 }, [
                j.$slots["header-close"] ? (c(), b("button", {
                  key: 0,
                  type: "button",
                  "data-bs-dismiss": "modal",
                  onClick: be[0] || (be[0] = (Ve) => G())
                }, [
                  B(j.$slots, "header-close", {}, void 0, !0)
                ])) : (c(), z(Me, {
                  key: 1,
                  type: "button",
                  "aria-label": e.headerCloseLabel,
                  "data-bs-dismiss": "modal",
                  white: s(f),
                  onClick: be[1] || (be[1] = (Ve) => G())
                }, null, 8, ["aria-label", "white"]))
              ], 64))
            ], 2)),
            q("div", {
              class: F(["modal-body", s(le)])
            }, [
              B(j.$slots, "default", {}, void 0, !0)
            ], 2),
            s(g) ? R("", !0) : (c(), b("div", {
              key: 1,
              class: F(["modal-footer", s(X)])
            }, [
              B(j.$slots, "footer", {}, () => [
                s(O) ? R("", !0) : (c(), z(We, {
                  key: 0,
                  type: "button",
                  class: "btn",
                  disabled: s(se),
                  size: e.buttonSize,
                  variant: e.cancelVariant,
                  onClick: be[2] || (be[2] = (Ve) => (G(), t("cancel")))
                }, {
                  default: E(() => [
                    Z(D(e.cancelTitle), 1)
                  ]),
                  _: 1
                }, 8, ["disabled", "size", "variant"])),
                Se(We, {
                  type: "button",
                  class: "btn",
                  disabled: s(ee),
                  size: e.buttonSize,
                  variant: e.okVariant,
                  onClick: be[3] || (be[3] = (Ve) => (G(), t("ok")))
                }, {
                  default: E(() => [
                    Z(D(e.okTitle), 1)
                  ]),
                  _: 1
                }, 8, ["disabled", "size", "variant"])
              ], !0)
            ], 2))
          ], 2)) : R("", !0)
        ], 2),
        s(v) === !1 ? (c(), b("div", {
          key: 0,
          class: "modal-backdrop fade show",
          onClick: be[4] || (be[4] = nt((Ve) => s(T) === !1 && G(), ["prevent"]))
        })) : R("", !0)
      ], 16, Ms)
    ]));
  }
});
const Ws = /* @__PURE__ */ he(Us, [["__scopeId", "data-v-eba3f010"]]), Xs = /* @__PURE__ */ x({
  __name: "BNav",
  props: {
    align: null,
    cardHeader: { default: !1 },
    fill: { default: !1 },
    justified: { default: !1 },
    pills: { default: !1 },
    small: { default: !1 },
    tabs: { default: !1 },
    tag: { default: "ul" },
    vertical: { default: !1 }
  },
  setup(e) {
    const t = e, a = i(o(t, "cardHeader")), l = i(o(t, "fill")), n = i(o(t, "justified")), r = i(o(t, "pills")), d = i(o(t, "small")), f = i(o(t, "tabs")), v = i(o(t, "vertical")), g = u(() => ({
      "nav-tabs": f.value,
      "nav-pills": r.value && !f.value,
      "card-header-tabs": !v.value && a.value && f.value,
      "card-header-pills": !v.value && a.value && r.value && !f.value,
      "flex-column": v.value,
      "nav-fill": !v.value && l.value,
      "nav-justified": !v.value && n.value,
      [`justify-content-${t.align}`]: !v.value && t.align !== void 0,
      small: d.value
    }));
    return (m, y) => (c(), z(K(e.tag), {
      class: F(["nav", s(g)])
    }, {
      default: E(() => [
        B(m.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Ks = /* @__PURE__ */ x({
  __name: "BNavForm",
  props: {
    role: null,
    id: null,
    floating: { default: !1 },
    novalidate: { default: !1 },
    validated: { default: !1 }
  },
  emits: ["submit"],
  setup(e, { emit: t }) {
    const a = e, l = (r) => t("submit", r), n = u(() => ({
      floating: a.floating,
      role: a.role,
      id: a.id,
      novalidate: a.novalidate,
      validated: a.validated
    }));
    return (r, d) => (c(), z(Ra, U(s(n), {
      class: "d-flex",
      onSubmit: nt(l, ["prevent"])
    }), {
      default: E(() => [
        B(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["onSubmit"]));
  }
}), Js = x({
  components: { BLink: ke },
  props: {
    ...ot(Ee, ["event", "routerTag"])
  },
  setup(e) {
    return { disabledBoolean: i(o(e, "disabled")) };
  }
}), Ys = { class: "nav-item" };
function Zs(e, t, a, l, n, r) {
  const d = It("b-link");
  return c(), b("li", Ys, [
    Se(d, U({ class: "nav-link" }, e.$props, {
      tabindex: e.disabledBoolean ? -1 : void 0,
      "aria-disabled": e.disabledBoolean ? !0 : void 0
    }), {
      default: E(() => [
        B(e.$slots, "default")
      ]),
      _: 3
    }, 16, ["tabindex", "aria-disabled"])
  ]);
}
const Qs = /* @__PURE__ */ he(Js, [["render", Zs]]), ei = { class: "nav-item dropdown" }, ti = /* @__PURE__ */ x({
  __name: "BNavItemDropdown",
  props: {
    id: null,
    text: null,
    toggleClass: null,
    size: null,
    offset: null,
    autoClose: { type: [Boolean, String], default: !0 },
    dark: { type: Boolean, default: !1 },
    dropleft: { type: Boolean, default: !1 },
    dropright: { type: Boolean, default: !1 },
    dropup: { type: Boolean, default: !1 },
    right: { type: Boolean, default: !1 },
    left: { type: [Boolean, String], default: !1 },
    split: { type: Boolean, default: !1 },
    splitVariant: null,
    noCaret: { type: Boolean, default: !1 },
    variant: { default: "link" }
  },
  setup(e) {
    return (t, a) => (c(), b("li", ei, [
      Se(qa, U(t.$props, { "is-nav": "" }), fl({ _: 2 }, [
        ve(t.$slots, (l, n) => ({
          name: n,
          fn: E((r) => [
            B(t.$slots, n, Ce(xe(r || {})))
          ])
        }))
      ]), 1040)
    ]));
  }
}), ai = { class: "navbar-text" }, li = /* @__PURE__ */ x({
  __name: "BNavText",
  props: {
    text: null
  },
  setup(e) {
    return (t, a) => (c(), b("li", ai, [
      B(t.$slots, "default", {}, () => [
        Z(D(e.text), 1)
      ])
    ]));
  }
}), ni = /* @__PURE__ */ x({
  __name: "BNavbar",
  props: {
    fixed: null,
    print: { default: !1 },
    sticky: null,
    tag: { default: "nav" },
    toggleable: { type: [Boolean, String], default: !1 },
    dark: { default: !1 },
    variant: null,
    container: { type: [String, Boolean], default: "fluid" }
  },
  setup(e) {
    const t = e, a = i(o(t, "print")), l = i(o(t, "dark")), n = u(
      () => t.tag === "nav" ? void 0 : "navigation"
    ), r = u(
      () => typeof t.toggleable == "string" ? `navbar-expand-${t.toggleable}` : t.toggleable === !1 ? "navbar-expand" : void 0
    ), d = u(
      () => t.container === !1 ? void 0 : t.container === !0 ? "container" : `container-${t.container}`
    ), f = u(() => ({
      "d-print": a.value,
      [`sticky-${t.sticky}`]: t.sticky !== void 0,
      "navbar-dark": l.value,
      [`bg-${t.variant}`]: t.variant !== void 0,
      [`fixed-${t.fixed}`]: t.fixed !== void 0,
      [`${r.value}`]: r.value !== void 0
    }));
    return (v, g) => (c(), z(K(e.tag), {
      class: F(["navbar", s(f)]),
      role: s(n)
    }, {
      default: E(() => [
        e.container !== !1 ? (c(), b("div", {
          key: 0,
          class: F(s(d))
        }, [
          B(v.$slots, "default")
        ], 2)) : B(v.$slots, "default", { key: 1 })
      ]),
      _: 3
    }, 8, ["class", "role"]));
  }
}), Zt = ot(Ee, ["event", "routerTag"]), oi = x({
  components: {
    BLink: ke
  },
  props: {
    tag: { type: String, default: "div" },
    ...Zt
  },
  setup(e) {
    const t = u(() => Ue(e)), a = u(() => t.value ? ke : e.tag);
    return {
      props: t.value ? fa(e, Zt) : {},
      computedTag: a
    };
  }
});
function si(e, t, a, l, n, r) {
  return c(), z(K(e.computedTag), U({ class: "navbar-brand" }, e.props), {
    default: E(() => [
      B(e.$slots, "default")
    ]),
    _: 3
  }, 16);
}
const ii = /* @__PURE__ */ he(oi, [["render", si]]), ri = /* @__PURE__ */ x({
  __name: "BNavbarNav",
  props: {
    align: null,
    fill: { default: !1 },
    justified: { default: !1 },
    small: { default: !1 },
    tag: { default: "ul" }
  },
  setup(e) {
    const t = e, a = i(o(t, "fill")), l = i(o(t, "justified")), n = i(o(t, "small")), r = u(() => ({
      "nav-fill": a.value,
      "nav-justified": l.value,
      [`justify-content-${t.align}`]: t.align !== void 0,
      small: n.value
    }));
    return (d, f) => (c(), b("ul", {
      class: F(["navbar-nav", s(r)])
    }, [
      B(d.$slots, "default")
    ], 2));
  }
}), ui = /* @__PURE__ */ q("span", { class: "navbar-toggler-icon" }, null, -1), di = /* @__PURE__ */ x({
  __name: "BNavbarToggle",
  props: {
    disabled: { default: !1 },
    label: { default: "Toggle navigation" },
    target: null
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const a = e, l = i(o(a, "disabled")), n = u(() => ({
      disabled: l.value,
      "aria-label": a.label
    })), r = u(() => ({
      disabled: l.value
    })), d = (f) => {
      l.value || t("click", f);
    };
    return (f, v) => Xe((c(), b("button", U({
      class: ["navbar-toggler", s(r)],
      type: "button"
    }, s(n), { onClick: d }), [
      B(f.$slots, "default", {}, () => [
        ui
      ])
    ], 16)), [
      [s(zt), s(l) ? void 0 : e.target]
    ]);
  }
}), ci = ["data-bs-backdrop", "data-bs-scroll"], fi = {
  key: 0,
  class: "offcanvas-header"
}, vi = {
  id: "offcanvasLabel",
  class: "offcanvas-title"
}, bi = { class: "offcanvas-body" }, mi = { key: 1 }, gi = /* @__PURE__ */ x({
  __name: "BOffcanvas",
  props: {
    dismissLabel: { default: "Close" },
    modelValue: { default: !1 },
    bodyScrolling: { default: !1 },
    backdrop: { default: !0 },
    placement: { default: "start" },
    title: null,
    noHeaderClose: { default: !1 },
    noHeader: { default: !1 }
  },
  emits: ["update:modelValue", "show", "shown", "hide", "hidden"],
  setup(e, { emit: t }) {
    const a = e, l = i(o(a, "modelValue")), n = i(o(a, "bodyScrolling")), r = i(o(a, "backdrop")), d = i(o(a, "noHeaderClose")), f = i(o(a, "noHeader")), v = M(), g = M();
    fe(v, "shown.bs.offcanvas", () => t("shown")), fe(v, "hidden.bs.offcanvas", () => t("hidden"));
    const m = () => {
      t("show"), t("update:modelValue", !0);
    }, y = () => {
      t("hide"), t("update:modelValue", !1);
    };
    fe(v, "show.bs.offcanvas", () => {
      m();
    }), fe(v, "hide.bs.offcanvas", () => {
      y();
    }), me(() => {
      var T;
      g.value = new hl(v.value), l.value && ((T = g.value) == null || T.show(v.value));
    });
    const p = u(() => ({
      [`offcanvas-${a.placement}`]: !!a.placement
    }));
    return ie(
      () => l.value,
      (T) => {
        var V, h;
        T ? (V = g.value) == null || V.show(v.value) : (h = g.value) == null || h.hide();
      }
    ), (T, V) => (c(), b("div", {
      ref_key: "element",
      ref: v,
      class: F(["offcanvas", s(p)]),
      tabindex: "-1",
      "aria-labelledby": "offcanvasLabel",
      "data-bs-backdrop": s(r),
      "data-bs-scroll": s(n)
    }, [
      s(f) ? R("", !0) : (c(), b("div", fi, [
        B(T.$slots, "header", Ce(xe({ visible: e.modelValue, placement: e.placement, hide: y })), () => [
          q("h5", vi, [
            B(T.$slots, "title", {}, () => [
              Z(D(e.title), 1)
            ])
          ]),
          s(d) ? R("", !0) : (c(), z(Me, {
            key: 0,
            type: "button",
            class: "text-reset",
            "data-bs-dismiss": "offcanvas",
            "aria-label": e.dismissLabel
          }, null, 8, ["aria-label"]))
        ])
      ])),
      q("div", bi, [
        B(T.$slots, "default")
      ]),
      T.$slots.footer ? (c(), b("div", mi, [
        B(T.$slots, "footer", Ce(xe({ visible: e.modelValue, placement: e.placement, hide: y })))
      ])) : R("", !0)
    ], 10, ci));
  }
}), pt = { top: 0, left: 0, bottom: 0, right: 0 }, pi = "default", hi = "overlay", yi = x({
  components: { BTransition: lt },
  props: {
    bgColor: { type: String, required: !1 },
    blur: { type: String, default: "2px" },
    fixed: { type: [Boolean, String], default: !1 },
    noCenter: { type: [Boolean, String], default: !1 },
    noFade: { type: [Boolean, String], default: !1 },
    noWrap: { type: [Boolean, String], default: !1 },
    opacity: {
      type: [Number, String],
      default: 0.85,
      validator: (e) => {
        const t = Ft(e, 0);
        return t >= 0 && t <= 1;
      }
    },
    overlayTag: { type: String, default: "div" },
    rounded: { type: [Boolean, String], default: !1 },
    show: { type: [Boolean, String], default: !1 },
    spinnerSmall: { type: [Boolean, String], default: !1 },
    spinnerType: { type: String, default: "border" },
    spinnerVariant: { type: String, required: !1 },
    variant: { type: String, default: "light" },
    wrapTag: { type: String, default: "div" },
    zIndex: { type: [Number, String], default: 10 }
  },
  emits: ["click", "hidden", "shown"],
  setup(e, { slots: t, emit: a }) {
    const l = i(o(e, "fixed")), n = i(o(e, "noCenter")), r = i(o(e, "noFade")), d = i(o(e, "noWrap")), f = i(o(e, "show")), v = i(o(e, "spinnerSmall")), g = u(
      () => e.rounded === !0 || e.rounded === "" ? "rounded" : e.rounded ? `rounded-${e.rounded}` : ""
    ), m = u(
      () => e.variant && !e.bgColor ? `bg-${e.variant}` : ""
    ), y = u(() => ({
      spinnerType: e.spinnerType || null,
      spinnerVariant: e.spinnerVariant || null,
      spinnerSmall: v.value
    }));
    return () => {
      const p = (k) => Q(It("BSpinner"), {
        type: k.spinnerType,
        variant: k.spinnerVariant,
        small: v.value
      });
      let T = "";
      if (f.value) {
        const k = Q("div", {
          class: ["position-absolute", m.value, g.value],
          style: {
            ...pt,
            opacity: e.opacity,
            backgroundColor: e.bgColor || null,
            backdropFilter: e.blur ? `blur(${e.blur})` : null
          }
        }), $ = Q(
          "div",
          {
            class: "position-absolute",
            style: n.value ? { ...pt } : { top: "50%", left: "50%", transform: "translateX(-50%) translateY(-50%)" }
          },
          $e(hi, y.value, t) || p(y.value) || ""
        );
        T = Q(
          e.overlayTag,
          {
            class: [
              "b-overlay",
              {
                "position-absolute": !d.value || d.value && !l.value,
                "position-fixed": d.value && l.value
              }
            ],
            style: {
              ...pt,
              zIndex: e.zIndex || 10
            },
            onClick: (O) => a("click", O),
            key: "overlay"
          },
          [k, $]
        );
      }
      const V = () => Q(
        lt,
        {
          noFade: r.value,
          transProps: { enterToClass: "show" },
          name: "fade",
          onAfterEnter: () => a("shown"),
          onAfterLeave: () => a("hidden")
        },
        { default: () => T }
      );
      return d.value ? V() : Q(
        e.wrapTag,
        {
          class: ["b-overlay-wrap position-relative"],
          "aria-busy": f.value ? "true" : null
        },
        [Q("span", $e(pi, {}, t)), V()]
      );
    };
  }
}), Bi = 5, Ja = 20, Ya = 0, Te = 3, $i = "ellipsis-text", ki = "first-text", Si = "last-text", Ci = "next-text", Ti = "page", wi = "prev-text", Qt = (e) => Math.max(Re(e) || Ja, 1), ea = (e) => Math.max(Re(e) || Ya, 0), Vi = (e, t) => {
  const a = Re(e) || 1;
  return a > t ? t : a < 1 ? 1 : a;
}, _i = x({
  name: "BPagination",
  props: {
    align: { type: String, default: "start" },
    ariaControls: { type: String, required: !1 },
    ariaLabel: { type: String, default: "Pagination" },
    disabled: { type: [Boolean, String], default: !1 },
    ellipsisClass: { type: [Array, String], default: () => [] },
    ellipsisText: { type: String, default: "\u2026" },
    firstClass: { type: [Array, String], default: () => [] },
    firstNumber: { type: [Boolean, String], default: !1 },
    firstText: { type: String, default: "\xAB" },
    hideEllipsis: { type: [Boolean, String], default: !1 },
    hideGotoEndButtons: { type: [Boolean, String], default: !1 },
    labelFirstPage: { type: String, default: "Go to first page" },
    labelLastPage: { type: String, default: "Go to last page" },
    labelNextPage: { type: String, default: "Go to next page" },
    labelPage: { type: String, default: "Go to page" },
    labelPrevPage: { type: String, default: "Go to previous page" },
    lastClass: { type: [Array, String], default: () => [] },
    lastNumber: { type: [Boolean, String], default: !1 },
    lastText: { type: String, default: "\xBB" },
    limit: { type: Number, default: Bi },
    modelValue: { type: Number, default: 1 },
    nextClass: { type: [Array, String], default: () => [] },
    nextText: { type: String, default: "\u203A" },
    pageClass: { type: [Array, String], default: () => [] },
    perPage: { type: Number, default: Ja },
    pills: { type: [Boolean, String], default: !1 },
    prevClass: { type: [Array, String], default: () => [] },
    prevText: { type: String, default: "\u2039" },
    size: { type: String, required: !1 },
    totalRows: { type: Number, default: Ya }
  },
  emits: ["update:modelValue", "page-click"],
  setup(e, { emit: t, slots: a }) {
    const l = i(o(e, "disabled")), n = i(o(e, "firstNumber")), r = i(o(e, "hideEllipsis")), d = i(o(e, "hideGotoEndButtons")), f = i(o(e, "lastNumber")), v = i(o(e, "pills")), g = yl(o(e, "align")), m = u(
      () => Math.ceil(ea(e.totalRows) / Qt(e.perPage))
    ), y = u(() => {
      let w;
      return m.value - e.modelValue + 2 < e.limit && e.limit > Te ? w = m.value - T.value + 1 : w = e.modelValue - Math.floor(T.value / 2), w < 1 ? w = 1 : w > m.value - T.value && (w = m.value - T.value + 1), e.limit <= Te && f.value && m.value === w + T.value - 1 && (w = Math.max(w - 1, 1)), w;
    }), p = u(() => {
      const w = m.value - e.modelValue;
      let C = !1;
      return w + 2 < e.limit && e.limit > Te ? e.limit > Te && (C = !0) : e.limit > Te && (C = !!(!r.value || n.value)), y.value <= 1 && (C = !1), C && n.value && y.value < 4 && (C = !1), C;
    }), T = u(() => {
      let w = e.limit;
      return m.value <= e.limit ? w = m.value : e.modelValue < e.limit - 1 && e.limit > Te ? ((!r.value || f.value) && (w = e.limit - (n.value ? 0 : 1)), w = Math.min(w, e.limit)) : m.value - e.modelValue + 2 < e.limit && e.limit > Te ? (!r.value || n.value) && (w = e.limit - (f.value ? 0 : 1)) : e.limit > Te && (w = e.limit - (r.value ? 0 : 2)), w;
    }), V = u(() => {
      const w = m.value - T.value;
      let C = !1;
      e.modelValue < e.limit - 1 && e.limit > Te ? (!r.value || f.value) && (C = !0) : e.limit > Te && (C = !!(!r.value || f.value)), y.value > w && (C = !1);
      const _ = y.value + T.value - 1;
      return C && f.value && _ > m.value - 3 && (C = !1), C;
    }), h = Ae({
      pageSize: Qt(e.perPage),
      totalRows: ea(e.totalRows),
      numberOfPages: m.value
    }), k = (w, C) => {
      if (C === e.modelValue)
        return;
      const { target: _ } = w, W = new st("page-click", {
        cancelable: !0,
        vueTarget: this,
        target: _
      });
      t("page-click", W, C), !W.defaultPrevented && t("update:modelValue", C);
    }, $ = u(() => e.size ? `pagination-${e.size}` : ""), O = u(() => v.value ? "b-pagination-pills" : "");
    ie(
      () => e.modelValue,
      (w) => {
        const C = Vi(w, m.value);
        C !== e.modelValue && t("update:modelValue", C);
      }
    ), ie(h, (w, C) => {
      w != null && (C.pageSize !== w.pageSize && C.totalRows === w.totalRows || C.numberOfPages !== w.numberOfPages && e.modelValue > C.numberOfPages) && t("update:modelValue", 1);
    });
    const N = u(() => {
      const w = [];
      for (let C = 0; C < T.value; C++)
        w.push({ number: y.value + C, classes: null });
      return w;
    });
    return () => {
      const w = [], C = N.value.map((X) => X.number), _ = (X) => X === e.modelValue, W = e.modelValue < 1, I = e.align === "fill", A = (X, ue, se, ee, Y, ye) => {
        const re = l.value || _(ye) || W || X < 1 || X > m.value, Be = X < 1 ? 1 : X > m.value ? m.value : X, we = { disabled: re, page: Be, index: Be - 1 }, G = $e(se, we, a) || ee || "";
        return Q(
          "li",
          {
            class: [
              "page-item",
              {
                disabled: re,
                "flex-fill": I,
                "d-flex": I && !re
              },
              Y
            ]
          },
          Q(
            re ? "span" : "button",
            {
              class: ["page-link", { "flex-grow-1": !re && I }],
              "aria-label": ue,
              "aria-controls": e.ariaControls || null,
              "aria-disabled": re ? "true" : null,
              role: "menuitem",
              type: re ? null : "button",
              tabindex: re ? null : "-1",
              onClick: (te) => {
                re || k(te, Be);
              }
            },
            G
          )
        );
      }, L = (X) => Q(
        "li",
        {
          class: [
            "page-item",
            "disabled",
            "bv-d-xs-down-none",
            I ? "flex-fill" : "",
            e.ellipsisClass
          ],
          role: "separator",
          key: `ellipsis-${X ? "last" : "first"}`
        },
        [
          Q(
            "span",
            { class: ["page-link"] },
            $e($i, {}, a) || e.ellipsisText || "..."
          )
        ]
      ), J = (X, ue) => {
        const se = _(X.number) && !W, ee = l.value ? null : se || W && ue === 0 ? "0" : "-1", Y = {
          active: se,
          disabled: l.value,
          page: X.number,
          index: X.number - 1,
          content: X.number
        }, ye = $e(Ti, Y, a) || X.number, re = Q(
          l.value ? "span" : "button",
          {
            class: ["page-link", { "flex-grow-1": !l.value && I }],
            "aria-controls": e.ariaControls || null,
            "aria-disabled": l.value ? "true" : null,
            "aria-label": e.labelPage ? `${e.labelPage} ${X.number}` : null,
            role: "menuitemradio",
            type: l.value ? null : "button",
            tabindex: ee,
            onClick: (Be) => {
              l.value || k(Be, X.number);
            }
          },
          ye
        );
        return Q(
          "li",
          {
            class: [
              "page-item",
              {
                disabled: l.value,
                active: se,
                "flex-fill": I,
                "d-flex": I && !l.value
              },
              e.pageClass
            ],
            role: "presentation",
            key: `page-${X.number}`
          },
          re
        );
      };
      if (!d.value && !n.value) {
        const X = A(
          1,
          e.labelFirstPage,
          ki,
          e.firstText,
          e.firstClass,
          1
        );
        w.push(X);
      }
      const le = A(
        e.modelValue - 1,
        e.labelFirstPage,
        wi,
        e.prevText,
        e.prevClass,
        1
      );
      w.push(le), n.value && C[0] !== 1 && w.push(J({ number: 1 }, 0)), p.value && w.push(L(!1)), N.value.forEach((X, ue) => {
        const se = p.value && n.value && C[0] !== 1 ? 1 : 0;
        w.push(J(X, ue + se));
      }), V.value && w.push(L(!0)), f.value && C[C.length - 1] !== m.value && w.push(J({ number: m.value }, -1));
      const ae = A(
        e.modelValue + 1,
        e.labelNextPage,
        Ci,
        e.nextText,
        e.nextClass,
        m.value
      );
      if (w.push(ae), !f.value && !d.value) {
        const X = A(
          m.value,
          e.labelLastPage,
          Si,
          e.lastText,
          e.lastClass,
          m.value
        );
        w.push(X);
      }
      return Q(
        "ul",
        {
          class: ["pagination", $.value, g.value, O.value],
          role: "menubar",
          "aria-disabled": l.value,
          "aria-label": e.ariaLabel || null
        },
        w
      );
    };
  }
}), Ai = x({
  props: {
    container: {
      type: [String, Object],
      default: "body"
    },
    content: { type: String },
    id: { type: String },
    customClass: { type: String, default: "" },
    noninteractive: { type: [Boolean, String], default: !1 },
    placement: { type: String, default: "right" },
    target: {
      type: [String, Object],
      default: void 0
    },
    title: { type: String },
    delay: { type: [Number, Object], default: 0 },
    triggers: { type: String, default: "click" },
    show: { type: [Boolean, String], default: !1 },
    variant: { type: String, default: void 0 },
    html: { type: [Boolean, String], default: !0 },
    sanitize: { type: [Boolean, String], default: !1 },
    offset: { type: String, default: "0" }
  },
  emits: ["show", "shown", "hide", "hidden", "inserted"],
  setup(e, { emit: t, slots: a }) {
    i(o(e, "noninteractive"));
    const l = i(o(e, "show")), n = i(o(e, "html")), r = i(o(e, "sanitize")), d = M(), f = M(), v = M(), g = M(), m = M(), y = u(() => ({
      [`b-popover-${e.variant}`]: e.variant !== void 0
    })), p = (h) => {
      if (typeof h == "string")
        return h;
      if (h instanceof HTMLElement)
        return h;
      if (typeof h < "u")
        return h.$el;
    }, T = (h) => {
      if (!!h) {
        if (typeof h == "string") {
          const k = document.getElementById(h);
          return k || void 0;
        }
        return h;
      }
    }, V = (h) => {
      f.value = T(p(h)), f.value && (v.value = new ht(f.value, {
        customClass: e.customClass,
        container: p(e.container),
        trigger: e.triggers,
        placement: e.placement,
        title: e.title || a.title ? g.value : "",
        content: m.value,
        html: n.value,
        delay: e.delay,
        sanitize: r.value,
        offset: e.offset
      }));
    };
    return me(() => {
      var h, k, $;
      Fe(() => {
        V(e.target);
      }), (k = (h = d.value) == null ? void 0 : h.parentNode) == null || k.removeChild(d.value), l.value && (($ = v.value) == null || $.show());
    }), At(() => {
      var h;
      (h = v.value) == null || h.dispose();
    }), ie(
      () => e.target,
      (h) => {
        var k;
        (k = v.value) == null || k.dispose(), V(h);
      }
    ), ie(
      () => l.value,
      (h, k) => {
        var $, O;
        h !== k && (h ? ($ = v.value) == null || $.show() : (O = v.value) == null || O.hide());
      }
    ), fe(f, "show.bs.popover", () => t("show")), fe(f, "shown.bs.popover", () => t("shown")), fe(f, "hide.bs.popover", () => t("hide")), fe(f, "hidden.bs.popover", () => t("hidden")), fe(f, "inserted.bs.popover", () => t("inserted")), {
      element: d,
      titleRef: g,
      contentRef: m,
      classes: y
    };
  }
}), xi = ["id"], Ii = { ref: "titleRef" }, Fi = { ref: "contentRef" };
function Oi(e, t, a, l, n, r) {
  return c(), b("div", {
    id: e.id,
    ref: "element",
    class: F(["popover b-popover", e.classes]),
    role: "tooltip",
    tabindex: "-1"
  }, [
    q("div", Ii, [
      B(e.$slots, "title", {}, () => [
        Z(D(e.title), 1)
      ])
    ], 512),
    q("div", Fi, [
      B(e.$slots, "default", {}, () => [
        Z(D(e.content), 1)
      ])
    ], 512)
  ], 10, xi);
}
const zi = /* @__PURE__ */ he(Ai, [["render", Oi]]), Za = x({
  props: {
    animated: { type: [Boolean, String], default: !1 },
    label: { type: String },
    labelHtml: { type: String },
    max: { type: [Number, String] },
    precision: { type: [Number, String], default: 0 },
    showProgress: { type: [Boolean, String], default: !1 },
    showValue: { type: [Boolean, String], default: !1 },
    striped: { type: [Boolean, String], default: !1 },
    value: { type: [Number, String], default: 0 },
    variant: { type: String }
  },
  setup(e, { slots: t }) {
    const a = i(o(e, "animated")), l = i(o(e, "showProgress")), n = i(o(e, "showValue")), r = i(o(e, "striped")), d = Ie(Qa), f = u(() => ({
      "progress-bar-animated": a.value || (d == null ? void 0 : d.animated),
      "progress-bar-striped": r.value || (d == null ? void 0 : d.striped) || a.value || (d == null ? void 0 : d.animated),
      [`bg-${e.variant}`]: e.variant !== void 0
    })), v = u(() => {
      if (n.value || (d == null ? void 0 : d.showValue))
        return parseFloat(e.value).toFixed(e.precision);
      if (l.value || (d == null ? void 0 : d.showProgress)) {
        const y = (e.value * 100 / parseInt(e.max || 100)).toString();
        return parseFloat(y).toFixed(e.precision);
      }
      return e.label || "";
    }), g = u(() => e.max || (d == null ? void 0 : d.max) ? `${e.value * 100 / parseInt(e.max || (d == null ? void 0 : d.max))}%` : typeof e.value == "string" ? e.value : `${e.value}%`), m = u(() => {
      const y = {
        class: ["progress-bar", f.value],
        role: "progressbar",
        "aria-valuenow": e.value,
        "aria-valuemin": 0,
        "aria-valuemax": e.max,
        style: { width: g.value }
      };
      return e.labelHtml ? {
        ...y,
        innerHTML: e.labelHtml
      } : y;
    });
    return () => {
      var y;
      return Q("div", m.value, ((y = t.default) == null ? void 0 : y.call(t)) || v.value);
    };
  }
}), Qa = Symbol(), Pi = /* @__PURE__ */ x({
  __name: "BProgress",
  props: {
    variant: null,
    max: null,
    height: null,
    animated: { default: !1 },
    precision: { default: 0 },
    showProgress: { default: !1 },
    showValue: { default: !1 },
    striped: { default: !1 },
    value: { default: 0 }
  },
  setup(e) {
    const t = e, a = i(o(t, "animated")), l = i(o(t, "showProgress")), n = i(o(t, "showValue")), r = i(o(t, "striped")), d = u(() => ({
      animated: a.value,
      max: t.max,
      precision: t.precision,
      showProgress: l.value,
      showValue: n.value,
      striped: r.value,
      value: t.value,
      variant: t.variant
    }));
    return je(Qa, {
      animated: a.value,
      max: t.max,
      showProgress: l.value,
      showValue: n.value,
      striped: r.value
    }), (f, v) => (c(), b("div", {
      class: "progress",
      style: qe({ height: e.height })
    }, [
      B(f.$slots, "default", {}, () => [
        Se(Za, Ce(xe(s(d))), null, 16)
      ])
    ], 4));
  }
}), ta = it("cols", [""], { type: [String, Number], default: null }), Ni = x({
  name: "BRow",
  props: {
    tag: { type: String, default: "div" },
    gutterX: { type: String, default: null },
    gutterY: { type: String, default: null },
    noGutters: { type: [Boolean, String], default: !1 },
    alignV: { type: String, default: null },
    alignH: { type: String, default: null },
    alignContent: { type: String, default: null },
    ...ta
  },
  setup(e) {
    const t = i(o(e, "noGutters")), a = ca(e, ta, "cols", "row-cols");
    return {
      classes: u(() => ({
        [`gx-${e.gutterX}`]: e.gutterX !== null,
        [`gy-${e.gutterY}`]: e.gutterY !== null,
        "g-0": t.value,
        [`align-items-${e.alignV}`]: e.alignV !== null,
        [`justify-content-${e.alignH}`]: e.alignH !== null,
        [`align-content-${e.alignContent}`]: e.alignContent !== null
      })),
      rowColsClasses: a
    };
  }
});
function Li(e, t, a, l, n, r) {
  return c(), z(K(e.tag), {
    class: F(["row", [e.classes, e.rowColsClasses]])
  }, {
    default: E(() => [
      B(e.$slots, "default")
    ]),
    _: 3
  }, 8, ["class"]);
}
const Ei = /* @__PURE__ */ he(Ni, [["render", Li]]), et = /* @__PURE__ */ x({
  __name: "BSkeleton",
  props: {
    height: null,
    width: null,
    size: null,
    animation: { default: "wave" },
    type: { default: "text" },
    variant: null
  },
  setup(e) {
    const t = e, a = u(() => [
      `b-skeleton-${t.type}`,
      {
        [`b-skeleton-animate-${t.animation}`]: typeof t.animation == "boolean" ? !1 : t.animation,
        [`bg-${t.variant}`]: t.variant !== void 0
      }
    ]), l = u(() => ({
      width: t.size || t.width,
      height: t.size || t.height
    }));
    return (n, r) => (c(), b("div", {
      class: F(["b-skeleton", s(a)]),
      style: qe(s(l))
    }, null, 6));
  }
}), Hi = /* @__PURE__ */ x({
  __name: "BSkeletonIcon",
  props: {
    animation: { default: "wave" }
  },
  setup(e) {
    const t = e, a = u(() => [`b-skeleton-animate-${t.animation}`]);
    return (l, n) => (c(), b("div", {
      class: F(["b-skeleton-icon-wrapper position-relative d-inline-block overflow-hidden", s(a)])
    }, [
      B(l.$slots, "default")
    ], 2));
  }
}), Et = /* @__PURE__ */ x({
  __name: "BTableSimple",
  props: {
    bordered: { default: !1 },
    borderless: { default: !1 },
    borderVariant: null,
    captionTop: { default: !1 },
    dark: { default: !1 },
    hover: { default: !1 },
    responsive: { type: [Boolean, String], default: !1 },
    stacked: { type: [Boolean, String], default: !1 },
    striped: { default: !1 },
    small: { default: !1 },
    tableClass: null,
    tableVariant: null,
    stickyHeader: { default: !1 }
  },
  setup(e) {
    const t = e, a = i(o(t, "captionTop")), l = i(o(t, "borderless")), n = i(o(t, "bordered")), r = i(o(t, "dark")), d = i(o(t, "hover")), f = i(o(t, "small")), v = i(o(t, "striped")), g = i(o(t, "stickyHeader")), m = u(() => [
      "table",
      "b-table",
      {
        "table-bordered": n.value,
        "table-borderless": l.value,
        [`border-${t.borderVariant}`]: t.borderVariant !== void 0,
        "caption-top": a.value,
        "table-dark": r.value,
        "table-hover": d.value,
        "b-table-stacked": typeof t.stacked == "boolean" && t.stacked,
        [`b-table-stacked-${t.stacked}`]: typeof t.stacked == "string",
        "table-striped": v.value,
        "table-sm": f.value,
        [`table-${t.tableVariant}`]: t.tableVariant !== void 0
      },
      t.tableClass
    ]), y = u(() => [
      {
        "table-responsive": t.responsive === !0,
        [`table-responsive-${t.responsive}`]: typeof t.responsive == "string",
        "b-table-sticky-header": g.value
      }
    ]);
    return (p, T) => e.responsive ? (c(), b("div", {
      key: 1,
      class: F(s(y))
    }, [
      q("table", {
        role: "table",
        class: F(s(m))
      }, [
        B(p.$slots, "default")
      ], 2)
    ], 2)) : (c(), b("table", {
      key: 0,
      role: "table",
      class: F(s(m))
    }, [
      B(p.$slots, "default")
    ], 2));
  }
}), Di = { key: 0 }, qi = { key: 1 }, Ri = /* @__PURE__ */ x({
  __name: "BSkeletonTable",
  props: {
    animation: { default: "wave" },
    columns: { default: 5 },
    hideHeader: { default: !1 },
    rows: { default: 3 },
    showFooter: { default: !1 },
    tableProps: null
  },
  setup(e) {
    const t = e, a = i(o(t, "hideHeader")), l = i(o(t, "showFooter"));
    return (n, r) => (c(), z(Et, Ce(xe(e.tableProps)), {
      default: E(() => [
        s(a) ? R("", !0) : (c(), b("thead", Di, [
          q("tr", null, [
            (c(!0), b(oe, null, ve(e.columns, (d, f) => (c(), b("th", { key: f }, [
              Se(et)
            ]))), 128))
          ])
        ])),
        q("tbody", null, [
          (c(!0), b(oe, null, ve(e.rows, (d, f) => (c(), b("tr", { key: f }, [
            (c(!0), b(oe, null, ve(e.columns, (v, g) => (c(), b("td", { key: g }, [
              Se(et, { width: "75%" })
            ]))), 128))
          ]))), 128))
        ]),
        s(l) ? (c(), b("tfoot", qi, [
          q("tr", null, [
            (c(!0), b(oe, null, ve(e.columns, (d, f) => (c(), b("th", { key: f }, [
              Se(et)
            ]))), 128))
          ])
        ])) : R("", !0)
      ]),
      _: 1
    }, 16));
  }
}), ji = /* @__PURE__ */ x({
  __name: "BSkeletonWrapper",
  props: {
    loading: { default: !1 }
  },
  setup(e) {
    const a = i(o(e, "loading"));
    return (l, n) => s(a) ? B(l.$slots, "loading", { key: 0 }) : B(l.$slots, "default", { key: 1 });
  }
}), Mi = () => {
  const e = (f, v) => {
    const g = [];
    return !(f != null && f.length) && (v == null ? void 0 : v.length) ? (Object.keys(v[0]).forEach((m) => g.push({ key: m, label: Ht(m) })), g) : (Array.isArray(f) && f.forEach((m) => {
      typeof m == "string" ? g.push({ key: m, label: Ht(m) }) : Bl(m) && m.key && typeof m.key == "string" && g.push({ ...m });
    }), g);
  }, t = M([]), a = (f, v, g, m) => {
    if (t.value = tt(v), "isFilterableTable" in m && m.isFilterableTable.value === !0 && g.filter && (t.value = r(t.value, g.filter, g.filterable), l.value && l.value(t.value)), "isSortable" in m && m.isSortable.value === !0 && (t.value = n(f, t.value, {
      key: g.sortBy,
      desc: m.sortDescBoolean.value
    })), g.perPage !== void 0) {
      const y = (g.currentPage - 1) * g.perPage;
      t.value = t.value.splice(y, g.perPage);
    }
    return t.value;
  }, l = M(void 0), n = (f, v, g) => {
    if (!g || !g.key)
      return v;
    const m = g.key;
    return v.sort((y, p) => {
      const T = (k) => typeof k == "object" ? JSON.stringify(k) : k;
      return T(y[m]) > T(p[m]) ? g.desc ? -1 : 1 : T(p[m]) > T(y[m]) ? g.desc ? 1 : -1 : 0;
    });
  }, r = (f, v, g) => f.filter(
    (m) => Object.entries(m).filter((y) => {
      const [p, T] = y;
      return p[0] === "_" || g.length > 0 && !g.includes(p) ? !1 : (typeof T == "object" ? JSON.stringify(Object.values(T)) : typeof T == "string" ? T : T.toString()).toLowerCase().includes(v.toLowerCase());
    }).length > 0
  );
  return {
    normaliseFields: e,
    mapItems: a,
    internalItems: t,
    updateInternalItems: async (f) => {
      try {
        return t.value = await yt(f), t.value;
      } catch {
        return;
      }
    },
    filterEvent: l
  };
}, Gi = ["title", "abbr", "onClick"], Ui = { class: "d-inline-flex flex-nowrap align-items-center gap-1" }, Wi = {
  key: 0,
  class: "b-table-sort-icon text-muted small"
}, Xi = { key: 1 }, Ki = ["onClick", "onDblclick", "onMouseenter", "onMouseleave"], Ji = ["colspan"], Yi = ["colspan"], Zi = { class: "d-flex align-items-center justify-content-center gap-2" }, Qi = /* @__PURE__ */ q("strong", null, "Loading...", -1), er = {
  key: 1,
  class: "b-table-empty-slot"
}, tr = ["colspan"], ar = { key: 0 }, lr = ["title", "abbr", "onClick"], nr = { key: 1 }, or = { key: 2 }, sr = { key: 3 }, ir = /* @__PURE__ */ x({
  __name: "BTable",
  props: {
    align: null,
    caption: null,
    captionTop: { default: !1 },
    borderless: { default: !1 },
    bordered: { default: !1 },
    borderVariant: null,
    dark: { default: !1 },
    fields: { default: () => [] },
    footClone: { default: !1 },
    hover: { default: !1 },
    items: { default: () => [] },
    provider: null,
    noProvider: null,
    noProviderPaging: null,
    noProviderSorting: null,
    noProviderFiltering: null,
    responsive: { type: [Boolean, String], default: !1 },
    small: { default: !1 },
    striped: { default: !1 },
    variant: null,
    sortBy: null,
    sortDesc: { default: !1 },
    sortInternal: { default: !0 },
    selectable: { default: !1 },
    stickySelect: { default: !1 },
    selectHead: { type: [Boolean, String], default: !0 },
    selectMode: { default: "single" },
    selectionVariant: { default: "primary" },
    stickyHeader: { default: !1 },
    busy: { default: !1 },
    showEmpty: { default: !1 },
    perPage: null,
    currentPage: { default: 1 },
    filter: null,
    filterable: null,
    emptyText: { default: "There are no records to show" },
    emptyFilteredText: { default: "There are no records matching your request" }
  },
  emits: ["headClicked", "rowClicked", "rowDblClicked", "rowHovered", "rowUnhovered", "rowSelected", "rowUnselected", "selection", "update:busy", "update:sortBy", "update:sortDesc", "sorted", "filtered"],
  setup(e, { expose: t, emit: a }) {
    const l = e, n = i(o(l, "footClone")), r = i(o(l, "sortDesc")), d = i(o(l, "sortInternal")), f = i(o(l, "selectable")), v = i(o(l, "stickySelect")), g = i(o(l, "busy")), m = i(o(l, "showEmpty")), y = i(o(l, "showEmpty")), p = i(o(l, "showEmpty")), T = i(o(l, "showEmpty")), V = M(g.value), h = Le(), k = u(() => ({
      [`align-${l.align}`]: l.align !== void 0,
      "b-table-selectable": f.value,
      [`b-table-select-${l.selectMode}`]: f.value,
      "b-table-selecting user-select-none": f.value && ye.value,
      "b-table-busy": V.value,
      "b-table-sortable": se.value,
      "b-table-sort-desc": se.value && r.value === !0,
      "b-table-sort-asc": se.value && r.value === !1
    })), $ = u(() => ({
      bordered: l.bordered,
      borderless: l.borderless,
      borderVariant: l.borderVariant,
      captionTop: l.captionTop,
      dark: l.dark,
      hover: l.hover,
      responsive: l.responsive,
      striped: l.striped,
      small: l.small,
      tableClass: k.value,
      tableVariant: l.variant,
      stickyHeader: l.stickyHeader
    })), O = Mi();
    O.filterEvent.value = async (S) => {
      if (_.value) {
        await we();
        return;
      }
      const H = await yt(S);
      a("filtered", H);
    };
    const N = u(() => O.normaliseFields(l.fields, l.items)), w = u(
      () => N.value.length + (f.value ? 1 : 0)
    ), C = u(() => l.filter !== void 0 && l.filter !== ""), _ = u(() => l.provider !== void 0), W = u(() => se.value && d.value === !0), I = u(() => _.value ? O.internalItems.value : W.value ? O.mapItems(l.fields, l.items, l, {
      isSortable: se,
      isFilterableTable: C,
      sortDescBoolean: r
    }) : l.items), A = (S) => typeof S == "string" ? Dt(S) : S.label !== void 0 ? S.label : typeof S.key == "string" ? Dt(S.key) : S.key, L = (S, H, ne = !1) => {
      const P = typeof S == "string" ? S : S.key;
      a("headClicked", P, S, H, ne), ee(S);
    }, J = (S, H, ne) => {
      a("rowClicked", S, H, ne), Be(S, H, ne.shiftKey);
    }, le = (S, H, ne) => a("rowDblClicked", S, H, ne), ae = (S, H, ne) => a("rowHovered", S, H, ne), X = (S, H, ne) => a("rowUnhovered", S, H, ne), ue = u(
      () => f.value && (!!l.selectHead || h.selectHead !== void 0)
    ), se = u(
      () => l.fields.filter((S) => typeof S == "string" ? !1 : S.sortable).length > 0
    ), ee = (S) => {
      if (!se.value)
        return;
      const H = typeof S == "string" ? S : S.key, ne = typeof S == "string" ? !1 : S.sortable;
      if (se.value === !0 && ne === !0) {
        const P = !r.value;
        H !== l.sortBy && a("update:sortBy", H), a("update:sortDesc", P), a("sorted", H, P);
      }
    }, Y = M(/* @__PURE__ */ new Set([])), ye = u(() => Y.value.size > 0), re = () => {
      !f.value || a("selection", Array.from(Y.value));
    }, Be = (S, H, ne = !1) => {
      if (!!f.value) {
        if (Y.value.has(S))
          Y.value.delete(S), a("rowUnselected", S);
        else if (l.selectMode === "single" && Y.value.size > 0 && (Y.value.forEach((P) => a("rowUnselected", P)), Y.value.clear()), l.selectMode === "range" && Y.value.size > 0 && ne) {
          const P = Array.from(Y.value).pop(), pe = I.value.findIndex((Pe) => Pe === P), de = Math.min(pe, H), ft = Math.max(pe, H);
          I.value.slice(de, ft + 1).forEach((Pe) => {
            Y.value.has(Pe) || (Y.value.add(Pe), a("rowSelected", Pe));
          });
        } else
          Y.value.add(S), a("rowSelected", S);
        re();
      }
    }, we = async () => {
      if (!_.value || !l.provider || V.value)
        return;
      V.value = !0;
      const S = new Proxy(
        {
          currentPage: l.currentPage,
          filter: l.filter,
          sortBy: l.sortBy,
          sortDesc: l.sortDesc,
          perPage: l.perPage
        },
        {
          get(ne, P) {
            return P in ne ? ne[P] : void 0;
          },
          set() {
            return console.error("BTable provider context is a read-only object."), !0;
          }
        }
      ), H = l.provider(S, O.updateInternalItems);
      if (H !== void 0) {
        if (H instanceof Promise)
          try {
            const ne = await H;
            return Array.isArray(ne) ? await O.updateInternalItems(ne) : void 0;
          } finally {
            V.value || (V.value = !1);
          }
        try {
          return await O.updateInternalItems(H);
        } finally {
          V.value && (V.value = !1);
        }
      }
    }, G = (S) => {
      S._showDetails = !S._showDetails;
    }, te = (S) => [
      S.class,
      S.thClass,
      S.variant ? `table-${S.variant}` : void 0,
      {
        "b-table-sortable-column": se.value && S.sortable,
        "b-table-sticky-column": S.stickyColumn
      }
    ], j = (S, H) => [
      S.class,
      S.tdClass,
      S.variant ? `table-${S.variant}` : void 0,
      (H == null ? void 0 : H._cellVariants) && (H == null ? void 0 : H._cellVariants[S.key]) ? `table-${H == null ? void 0 : H._cellVariants[S.key]}` : void 0,
      {
        "b-table-sticky-column": S.stickyColumn
      }
    ], be = (S) => [
      S._rowVariant ? `table-${S._rowVariant}` : null,
      S._rowVariant ? `table-${S._rowVariant}` : null,
      f.value && Y.value.has(S) ? `selected table-${l.selectionVariant}` : null
    ], Ve = () => {
      if (!f.value)
        return;
      const S = Y.value.size > 0 ? Array.from(Y.value) : [];
      Y.value = /* @__PURE__ */ new Set([...I.value]), Y.value.forEach((H) => {
        S.includes(H) || a("rowSelected", H);
      }), re();
    }, ut = () => {
      !f.value || (Y.value.forEach((S) => {
        a("rowUnselected", S);
      }), Y.value = /* @__PURE__ */ new Set([]), re());
    }, dt = (S) => {
      if (!f.value)
        return;
      const H = I.value[S];
      !H || Y.value.has(H) || (Y.value.add(H), a("rowSelected", H), re());
    }, ct = (S) => {
      if (!f.value)
        return;
      const H = I.value[S];
      !H || !Y.value.has(H) || (Y.value.delete(H), a("rowUnselected", H), re());
    };
    me(() => {
      _.value && we();
    }), ie(
      () => l.filter,
      (S, H) => {
        S === H || _.value || S || yt(l.items).then((ne) => a("filtered", ne));
      }
    );
    const ze = async (S, H, ne) => {
      if (H === ne)
        return;
      const P = (Pe) => l.noProvider && l.noProvider.includes(Pe), pe = ["currentPage", "perPage"].includes(S) && (P("paging") || y.value === !0), de = ["filter"].includes(S) && (P("filtering") || T.value === !0), ft = ["sortBy", "sortDesc"].includes(S) && (P("sorting") || p.value === !0);
      pe || de || ft || await we();
    };
    return ie(
      () => V.value,
      () => V.value !== g.value && a("update:busy", V.value)
    ), ie(
      () => g.value,
      () => V.value !== g.value && (V.value = g.value)
    ), ie(
      () => l.filter,
      (S, H) => ze("filter", S, H)
    ), ie(
      () => l.currentPage,
      (S, H) => ze("currentPage", S, H)
    ), ie(
      () => l.perPage,
      (S, H) => ze("perPage", S, H)
    ), ie(
      () => l.sortBy,
      (S, H) => ze("sortBy", S, H)
    ), ie(
      () => l.sortDesc,
      (S, H) => ze("sortDesc", S, H)
    ), t({
      selectAllRows: Ve,
      clearSelected: ut,
      selectRow: dt,
      unselectRow: ct
    }), (S, H) => (c(), z(Et, Ce(xe(s($))), {
      default: E(() => {
        var ne;
        return [
          q("thead", null, [
            S.$slots["thead-top"] ? B(S.$slots, "thead-top", { key: 0 }) : R("", !0),
            q("tr", null, [
              s(ue) ? (c(), b("th", {
                key: 0,
                class: F(["b-table-selection-column", {
                  "b-table-sticky-column": s(v)
                }])
              }, [
                B(S.$slots, "selectHead", {}, () => [
                  Z(D(typeof e.selectHead == "boolean" ? "Selected" : e.selectHead), 1)
                ])
              ], 2)) : R("", !0),
              (c(!0), b(oe, null, ve(s(N), (P) => (c(), b("th", U({
                key: P.key,
                scope: "col",
                class: te(P),
                title: P.headerTitle,
                abbr: P.headerAbbr,
                style: P.thStyle
              }, P.thAttr, {
                onClick: (pe) => L(P, pe)
              }), [
                q("div", Ui, [
                  B(S.$slots, "sortIcon", {
                    field: P,
                    sortBy: e.sortBy,
                    selected: P.key === e.sortBy,
                    isDesc: s(r),
                    direction: s(r) ? "desc" : "asc"
                  }, () => [
                    s(se) && P.sortable && P.key === e.sortBy ? (c(), b("span", Wi)) : R("", !0)
                  ]),
                  q("div", null, [
                    S.$slots["head(" + P.key + ")"] || S.$slots["head()"] ? B(S.$slots, S.$slots["head(" + P.key + ")"] ? "head(" + P.key + ")" : "head()", {
                      key: 0,
                      label: P.label
                    }) : (c(), b(oe, { key: 1 }, [
                      Z(D(A(P)), 1)
                    ], 64))
                  ])
                ])
              ], 16, Gi))), 128))
            ]),
            S.$slots["thead-sub"] ? (c(), b("tr", Xi, [
              (c(!0), b(oe, null, ve(s(N), (P) => (c(), b("td", {
                key: P.key,
                scope: "col",
                class: F([P.class, P.thClass, P.variant ? `table-${P.variant}` : ""])
              }, [
                S.$slots["thead-sub"] ? B(S.$slots, "thead-sub", U({
                  key: 0,
                  items: s(N)
                }, P)) : (c(), b(oe, { key: 1 }, [
                  Z(D(P.label), 1)
                ], 64))
              ], 2))), 128))
            ])) : R("", !0)
          ]),
          q("tbody", null, [
            (c(!0), b(oe, null, ve(s(I), (P, pe) => (c(), b(oe, { key: pe }, [
              q("tr", {
                class: F(be(P)),
                onClick: (de) => J(P, pe, de),
                onDblclick: (de) => le(P, pe, de),
                onMouseenter: (de) => ae(P, pe, de),
                onMouseleave: (de) => X(P, pe, de)
              }, [
                s(ue) ? (c(), b("td", {
                  key: 0,
                  class: F(["b-table-selection-column", {
                    "b-table-sticky-column": s(v)
                  }])
                }, [
                  B(S.$slots, "selectCell", {}, () => [
                    q("span", {
                      class: F(Y.value.has(P) ? "text-primary" : "")
                    }, "\u{1F5F9}", 2)
                  ])
                ], 2)) : R("", !0),
                (c(!0), b(oe, null, ve(s(N), (de) => (c(), b("td", U({
                  key: de.key
                }, de.tdAttr, {
                  class: j(de, P)
                }), [
                  S.$slots["cell(" + de.key + ")"] || S.$slots["cell()"] ? B(S.$slots, S.$slots["cell(" + de.key + ")"] ? "cell(" + de.key + ")" : "cell()", {
                    key: 0,
                    value: P[de.key],
                    index: pe,
                    item: P,
                    field: de,
                    items: e.items,
                    toggleDetails: () => G(P),
                    detailsShowing: P._showDetails
                  }) : (c(), b(oe, { key: 1 }, [
                    Z(D(P[de.key]), 1)
                  ], 64))
                ], 16))), 128))
              ], 42, Ki),
              P._showDetails === !0 && S.$slots["row-details"] ? (c(), b("tr", {
                key: 0,
                class: F(be(P))
              }, [
                q("td", { colspan: s(w) }, [
                  B(S.$slots, "row-details", {
                    item: P,
                    toggleDetails: () => G(P)
                  })
                ], 8, Ji)
              ], 2)) : R("", !0)
            ], 64))), 128)),
            V.value ? (c(), b("tr", {
              key: 0,
              class: F(["b-table-busy-slot", { "b-table-static-busy": s(I).length == 0 }])
            }, [
              q("td", { colspan: s(w) }, [
                B(S.$slots, "table-busy", {}, () => [
                  q("div", Zi, [
                    Se(Pt, { class: "align-middle" }),
                    Qi
                  ])
                ])
              ], 8, Yi)
            ], 2)) : R("", !0),
            s(m) && s(I).length === 0 ? (c(), b("tr", er, [
              q("td", { colspan: s(w) }, [
                B(S.$slots, "empty", {
                  items: s(I),
                  filtered: s(C)
                }, () => [
                  Z(D(s(C) ? e.emptyFilteredText : e.emptyText), 1)
                ])
              ], 8, tr)
            ])) : R("", !0)
          ]),
          s(n) ? (c(), b("tfoot", ar, [
            q("tr", null, [
              (c(!0), b(oe, null, ve(s(N), (P) => (c(), b("th", U({
                key: P.key
              }, P.thAttr, {
                scope: "col",
                class: [P.class, P.thClass, P.variant ? `table-${P.variant}` : ""],
                title: P.headerTitle,
                abbr: P.headerAbbr,
                style: P.thStyle,
                onClick: (pe) => L(P, pe, !0)
              }), D(P.label), 17, lr))), 128))
            ])
          ])) : S.$slots["custom-foot"] ? (c(), b("tfoot", nr, [
            B(S.$slots, "custom-foot", {
              fields: s(N),
              items: e.items,
              columns: (ne = s(N)) == null ? void 0 : ne.length
            })
          ])) : R("", !0),
          S.$slots["table-caption"] ? (c(), b("caption", or, [
            B(S.$slots, "table-caption")
          ])) : e.caption ? (c(), b("caption", sr, D(e.caption), 1)) : R("", !0)
        ];
      }),
      _: 3
    }, 16));
  }
}), rr = /* @__PURE__ */ x({
  __name: "BTbody",
  props: {
    variant: null
  },
  setup(e) {
    const t = e, a = u(() => ({
      [`thead-${t.variant}`]: t.variant !== void 0
    }));
    return (l, n) => (c(), b("tbody", {
      role: "rowgroup",
      class: F(s(a))
    }, [
      B(l.$slots, "default")
    ], 2));
  }
}), ur = ["scope", "colspan", "rowspan", "data-label"], dr = { key: 0 }, cr = /* @__PURE__ */ x({
  __name: "BTd",
  props: {
    colspan: null,
    rowspan: null,
    stackedHeading: null,
    stickyColumn: { default: !1 },
    variant: null
  },
  setup(e) {
    const t = e, a = i(o(t, "stickyColumn")), l = u(() => ({
      [`table-${t.variant}`]: t.variant !== void 0,
      "b-table-sticky-column": a.value,
      "table-b-table-default": a.value && !t.variant
    })), n = u(() => t.colspan ? "colspan" : t.rowspan ? "rowspan" : "col");
    return (r, d) => (c(), b("td", {
      role: "cell",
      scope: s(n),
      class: F(s(l)),
      colspan: e.colspan,
      rowspan: e.rowspan,
      "data-label": e.stackedHeading
    }, [
      e.stackedHeading ? (c(), b("div", dr, [
        B(r.$slots, "default")
      ])) : B(r.$slots, "default", { key: 1 })
    ], 10, ur));
  }
}), fr = /* @__PURE__ */ x({
  __name: "BTfoot",
  props: {
    variant: null
  },
  setup(e) {
    const t = e, a = u(() => ({
      [`table-${t.variant}`]: t.variant !== void 0
    }));
    return (l, n) => (c(), b("tfoot", {
      role: "rowgroup",
      class: F(s(a))
    }, [
      B(l.$slots, "default")
    ], 2));
  }
}), vr = ["scope", "colspan", "rowspan", "data-label"], br = { key: 0 }, mr = /* @__PURE__ */ x({
  __name: "BTh",
  props: {
    colspan: null,
    rowspan: null,
    stackedHeading: null,
    stickyColumn: { default: !1 },
    variant: null
  },
  setup(e) {
    const t = e, a = i(o(t, "stickyColumn")), l = u(() => ({
      [`table-${t.variant}`]: t.variant !== void 0,
      "b-table-sticky-column": a.value,
      "table-b-table-default": a.value && t.variant === void 0
    })), n = u(() => t.colspan ? "colspan" : t.rowspan ? "rowspan" : "col");
    return (r, d) => (c(), b("th", {
      role: "columnheader",
      scope: s(n),
      class: F(s(l)),
      colspan: e.colspan,
      rowspan: e.rowspan,
      "data-label": e.stackedHeading
    }, [
      e.stackedHeading !== void 0 ? (c(), b("div", br, [
        B(r.$slots, "default")
      ])) : B(r.$slots, "default", { key: 1 })
    ], 10, vr));
  }
}), gr = /* @__PURE__ */ x({
  __name: "BThead",
  props: {
    variant: null
  },
  setup(e) {
    const t = e, a = u(() => ({
      [`table-${t.variant}`]: t.variant !== void 0
    }));
    return (l, n) => (c(), b("thead", {
      role: "rowgroup",
      class: F(s(a))
    }, [
      B(l.$slots, "default")
    ], 2));
  }
}), pr = /* @__PURE__ */ x({
  __name: "BTr",
  props: {
    variant: null
  },
  setup(e) {
    const t = e, a = u(() => ({
      [`table-${t.variant}`]: t.variant !== void 0
    }));
    return (l, n) => (c(), b("tr", {
      role: "row",
      class: F(s(a))
    }, [
      B(l.$slots, "default")
    ], 2));
  }
}), hr = ["id", "data-bs-target", "aria-controls", "aria-selected", "onClick"], el = Symbol(), yr = /* @__PURE__ */ x({
  __name: "BTabs",
  props: {
    activeNavItemClass: null,
    activeTabClass: null,
    align: null,
    card: { default: !1 },
    contentClass: null,
    end: { default: !1 },
    fill: { default: !1 },
    id: null,
    justified: { default: !1 },
    lazy: { default: !1 },
    navClass: null,
    navWrapperClass: null,
    noFade: { default: !1 },
    noNavStyle: { default: !1 },
    pills: { default: !1 },
    small: { default: !1 },
    tag: { default: "div" },
    vertical: { default: !1 },
    modelValue: { default: -1 }
  },
  emits: ["update:modelValue", "activate-tab", "click"],
  setup(e, { emit: t }) {
    const a = e, l = i(o(a, "card")), n = i(o(a, "end")), r = i(o(a, "fill")), d = i(o(a, "justified")), f = i(o(a, "lazy")), v = i(o(a, "noFade")), g = i(o(a, "noNavStyle")), m = i(o(a, "pills")), y = i(o(a, "small")), p = i(o(a, "vertical")), T = Le(), V = M(a.modelValue), h = M(""), k = u({
      get: () => V.value,
      set: (I) => {
        V.value = I, $.value.length > 0 && I >= 0 && I < $.value.length ? h.value = $.value[I].buttonId : h.value = "", t("update:modelValue", I);
      }
    }), $ = u(() => {
      let I = [];
      return T.default && (I = W(T).map((A, L) => {
        A.props || (A.props = {});
        const J = A.props["button-id"] || _e("tab"), le = A.props.id || _e(), ae = k.value > -1 ? L === k.value : A.props.active === "", X = A.props["title-item-class"], ue = A.props["title-link-attributes"];
        return {
          buttonId: J,
          contentId: le,
          active: ae,
          disabled: A.props.disabled === "" || A.props.disabled === !0,
          navItemClasses: [
            {
              active: ae,
              disabled: A.props.disabled === "" || A.props.disabled === !0
            },
            ae && a.activeNavItemClass ? a.activeNavItemClass : null,
            A.props["title-link-class"]
          ],
          tabClasses: [
            {
              fade: !v.value
            },
            ae && a.activeTabClass ? a.activeTabClass : null
          ],
          target: `#${le}`,
          title: A.props.title,
          titleItemClass: X,
          titleLinkAttributes: ue,
          onClick: A.props.onClick,
          tab: A
        };
      })), I;
    }), O = u(() => !(($ == null ? void 0 : $.value) && $.value.length > 0)), N = u(() => ({
      "d-flex": p.value,
      "align-items-start": p.value
    })), w = u(() => ({
      "nav-pills": m.value,
      "flex-column me-3": p.value,
      [`justify-content-${a.align}`]: a.align !== void 0,
      "nav-fill": r.value,
      "card-header-tabs": l.value,
      "nav-justified": d.value,
      "nav-tabs": !g.value && !m.value,
      small: y.value
    })), C = (I) => {
      let A = !1;
      if (I !== void 0 && I > -1 && I < $.value.length && !$.value[I].disabled && (k.value < 0 || $.value[I].buttonId !== h.value)) {
        const L = new st("activate-tab", { cancelable: !0, vueTarget: this });
        t("activate-tab", I, k.value, L), L.defaultPrevented || (k.value = I, A = !0);
      }
      return !A && a.modelValue !== k.value && t("update:modelValue", k.value), A;
    }, _ = (I, A) => {
      var L;
      C(A), A >= 0 && !$.value[A].disabled && ((L = $.value[A]) == null ? void 0 : L.onClick) && typeof $.value[A].onClick == "function" && $.value[A].onClick(I);
    }, W = (I) => !I || !I.default ? [] : I.default().reduce((A, L) => (typeof L.type == "symbol" ? A = A.concat(L.children) : A.push(L), A), []).filter((A) => {
      var L;
      return ((L = A.type) == null ? void 0 : L.__name) === "BTab";
    });
    return C(V.value), ie(
      () => a.modelValue,
      (I, A) => {
        if (I === A)
          return;
        if (I = Math.max(I, -1), A = Math.max(A, -1), $.value.length <= 0) {
          k.value = -1;
          return;
        }
        const L = I > A;
        let J = I;
        const le = $.value.length - 1;
        for (; J >= 0 && J <= le && $.value[J].disabled; )
          J += L ? 1 : -1;
        if (J < 0) {
          C(0);
          return;
        }
        if (J >= $.value.length) {
          C($.value.length - 1);
          return;
        }
        C(J);
      }
    ), ie(
      () => $.value,
      () => {
        let I = $.value.map((A) => A.active && !A.disabled).lastIndexOf(!0);
        I < 0 && (k.value >= $.value.length ? I = $.value.map((A) => !A.disabled).lastIndexOf(!0) : $.value[k.value] && !$.value[k.value].disabled && (I = k.value)), I < 0 && (I = $.value.map((A) => !A.disabled).indexOf(!0)), $.value.forEach((A, L) => A.active = L === I), C(I);
      }
    ), me(() => {
      if (k.value < 0 && $.value.length > 0 && !$.value.some((I) => I.active)) {
        const I = $.value.map((A) => !A.disabled).indexOf(!0);
        C(I >= 0 ? I : -1);
      }
    }), je(el, {
      lazy: f.value,
      card: l.value
    }), (I, A) => (c(), z(K(e.tag), {
      id: e.id,
      class: F(["tabs", s(N)])
    }, {
      default: E(() => [
        s(n) ? (c(), b("div", {
          key: 0,
          class: F(["tab-content", e.contentClass])
        }, [
          (c(!0), b(oe, null, ve(s($), ({ tab: L, contentId: J, tabClasses: le, active: ae }, X) => (c(), z(K(L), {
            id: J,
            key: X,
            class: F(le),
            active: ae
          }, null, 8, ["id", "class", "active"]))), 128)),
          s(O) ? (c(), b("div", {
            key: "bv-empty-tab",
            class: F(["tab-pane active", { "card-body": s(l) }])
          }, [
            B(I.$slots, "empty")
          ], 2)) : R("", !0)
        ], 2)) : R("", !0),
        q("div", {
          class: F([e.navWrapperClass, { "card-header": s(l), "ms-auto": e.vertical && s(n) }])
        }, [
          q("ul", {
            class: F(["nav", [s(w), e.navClass]]),
            role: "tablist"
          }, [
            B(I.$slots, "tabs-start"),
            (c(!0), b(oe, null, ve(s($), ({ tab: L, buttonId: J, contentId: le, navItemClasses: ae, active: X, target: ue }, se) => (c(), b("li", {
              key: se,
              class: F(["nav-item", L.props["title-item-class"]])
            }, [
              q("button", U({
                id: J,
                class: ["nav-link", ae],
                "data-bs-toggle": "tab",
                "data-bs-target": ue,
                role: "tab",
                "aria-controls": le,
                "aria-selected": X
              }, L.props["title-link-attributes"], {
                onClick: nt((ee) => _(ee, se), ["stop", "prevent"])
              }), [
                L.children && L.children.title ? (c(), z(K(L.children.title), { key: 0 })) : (c(), b(oe, { key: 1 }, [
                  Z(D(L.props.title), 1)
                ], 64))
              ], 16, hr)
            ], 2))), 128)),
            B(I.$slots, "tabs-end")
          ], 2)
        ], 2),
        s(n) ? R("", !0) : (c(), b("div", {
          key: 1,
          class: F(["tab-content", e.contentClass])
        }, [
          (c(!0), b(oe, null, ve(s($), ({ tab: L, contentId: J, tabClasses: le, active: ae }, X) => (c(), z(K(L), {
            id: J,
            key: X,
            class: F(le),
            active: ae
          }, null, 8, ["id", "class", "active"]))), 128)),
          s(O) ? (c(), b("div", {
            key: "bv-empty-tab",
            class: F(["tab-pane active", { "card-body": s(l) }])
          }, [
            B(I.$slots, "empty")
          ], 2)) : R("", !0)
        ], 2))
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), Br = /* @__PURE__ */ x({
  __name: "BTab",
  props: {
    id: null,
    title: null,
    active: { default: !1 },
    buttonId: { default: void 0 },
    disabled: { default: !1 },
    lazy: { default: void 0 },
    lazyOnce: { default: void 0 },
    noBody: { type: [Boolean, String], default: !1 },
    tag: { default: "div" },
    titleItemClass: { default: void 0 },
    titleLinkAttributes: { default: void 0 },
    titleLinkClass: { default: void 0 }
  },
  setup(e) {
    const t = e, a = M(!1), l = i(o(t, "active")), n = i(o(t, "disabled")), r = i(o(t, t.lazyOnce !== void 0 ? "lazyOnce" : "lazy")), d = Ie(el, null), f = u(() => (d == null ? void 0 : d.lazy) || r.value), v = u(() => t.lazyOnce !== void 0), g = u(() => l.value && !n.value), m = u(() => {
      const p = f.value && v.value && a.value;
      return g.value || !f.value || p;
    }), y = u(() => ({
      active: l.value,
      show: l.value,
      "card-body": (d == null ? void 0 : d.card) && t.noBody === !1
    }));
    return ie(
      () => m.value,
      (p) => {
        p && !a.value && (a.value = !0);
      }
    ), (p, T) => (c(), z(K(e.tag), {
      id: e.id,
      class: F(["tab-pane", s(y)]),
      role: "tabpanel",
      "aria-labelledby": "profile-tab"
    }, {
      default: E(() => [
        s(m) ? B(p.$slots, "default", { key: 0 }) : R("", !0)
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), $r = {
  BAccordion: Gl,
  BAccordionItem: un,
  BNavText: li,
  BAlert: cn,
  BAvatar: gn,
  BAvatarGroup: fn,
  BNavForm: Ks,
  BBadge: $n,
  BBreadcrumb: Vn,
  BBreadcrumbItem: _a,
  BButton: We,
  BButtonGroup: In,
  BButtonToolbar: On,
  BCard: Pn,
  BCardBody: Oa,
  BCardFooter: za,
  BCardGroup: Nn,
  BCardHeader: xa,
  BCardImg: St,
  BCardSubTitle: Fa,
  BCardText: Ln,
  BCardTitle: Ia,
  BCarousel: Xn,
  BCarouselSlide: eo,
  BCloseButton: Me,
  BCol: Ge,
  BCollapse: Ta,
  BContainer: uo,
  BDropdown: qa,
  BDropdownDivider: bo,
  BDropdownForm: yo,
  BDropdownGroup: So,
  BDropdownHeader: Vo,
  BDropdownItem: Ao,
  BDropdownItemButton: Io,
  BDropdownText: zo,
  BForm: Ra,
  BFormCheckbox: ja,
  BFormCheckboxGroup: Go,
  BFormFloatingLabel: Eo,
  BFormGroup: Qo,
  BFormInput: ls,
  BFormInvalidFeedback: wt,
  BFormRadio: Ga,
  BFormRadioGroup: us,
  BFormRow: Qe,
  BFormSelect: vs,
  BFormSelectOption: Nt,
  BFormSelectOptionGroup: Ua,
  BFormText: Vt,
  BFormTextarea: Fs,
  BFormTag: Wa,
  BFormTags: _s,
  BFormValidFeedback: _t,
  BImg: Na,
  BInputGroup: Hs,
  BInputGroupAddon: Lt,
  BInputGroupAppend: Ds,
  BInputGroupPrepend: qs,
  BInputGroupText: Xa,
  BLink: ke,
  BListGroup: Rs,
  BListGroupItem: js,
  BModal: Ws,
  BNav: Xs,
  BNavbar: ni,
  BNavbarBrand: ii,
  BNavbarNav: ri,
  BNavbarToggle: di,
  BNavItem: Qs,
  BNavItemDropdown: ti,
  BOffcanvas: gi,
  BOverlay: yi,
  BPagination: _i,
  BPopover: zi,
  BProgress: Pi,
  BProgressBar: Za,
  BRow: Ei,
  BSkeleton: et,
  BSkeletonIcon: Hi,
  BSkeletonTable: Ri,
  BSkeletonWrapper: ji,
  BSpinner: Pt,
  BTab: Br,
  BTable: ir,
  BTableSimple: Et,
  BTbody: rr,
  BTd: cr,
  BTfoot: fr,
  BTh: mr,
  BThead: gr,
  BTr: pr,
  BToast: Ea,
  BToaster: Ct,
  BToastContainer: Ct,
  BTabs: yr,
  BTransition: lt,
  BToastPlugin: ro
};
const Tr = {
  install(e, t = {}) {
    Object.entries($r).forEach(([a, l]) => {
      e.component(a, l);
    }), Object.entries(ln).forEach(([a, l]) => {
      e.directive(a, l);
    }), Rl(e);
  }
};
export {
  Gl as BAccordion,
  un as BAccordionItem,
  cn as BAlert,
  gn as BAvatar,
  fn as BAvatarGroup,
  $n as BBadge,
  Vn as BBreadcrumb,
  _a as BBreadcrumbItem,
  We as BButton,
  In as BButtonGroup,
  On as BButtonToolbar,
  Pn as BCard,
  Oa as BCardBody,
  za as BCardFooter,
  Nn as BCardGroup,
  xa as BCardHeader,
  St as BCardImg,
  Fa as BCardSubTitle,
  Ln as BCardText,
  Ia as BCardTitle,
  Xn as BCarousel,
  eo as BCarouselSlide,
  Me as BCloseButton,
  Ge as BCol,
  Ta as BCollapse,
  uo as BContainer,
  qa as BDropdown,
  bo as BDropdownDivider,
  yo as BDropdownForm,
  So as BDropdownGroup,
  Vo as BDropdownHeader,
  Ao as BDropdownItem,
  Io as BDropdownItemButton,
  zo as BDropdownText,
  Ra as BForm,
  ja as BFormCheckbox,
  Go as BFormCheckboxGroup,
  Eo as BFormFloatingLabel,
  Qo as BFormGroup,
  ls as BFormInput,
  wt as BFormInvalidFeedback,
  Ga as BFormRadio,
  us as BFormRadioGroup,
  Qe as BFormRow,
  vs as BFormSelect,
  Nt as BFormSelectOption,
  Ua as BFormSelectOptionGroup,
  Wa as BFormTag,
  _s as BFormTags,
  Vt as BFormText,
  Fs as BFormTextarea,
  _t as BFormValidFeedback,
  Na as BImg,
  Hs as BInputGroup,
  Lt as BInputGroupAddon,
  Ds as BInputGroupAppend,
  qs as BInputGroupPrepend,
  Xa as BInputGroupText,
  ke as BLink,
  Rs as BListGroup,
  js as BListGroupItem,
  Ws as BModal,
  Xs as BNav,
  Ks as BNavForm,
  Qs as BNavItem,
  ti as BNavItemDropdown,
  li as BNavText,
  ni as BNavbar,
  ii as BNavbarBrand,
  ri as BNavbarNav,
  di as BNavbarToggle,
  gi as BOffcanvas,
  yi as BOverlay,
  _i as BPagination,
  zi as BPopover,
  Pi as BProgress,
  Za as BProgressBar,
  Ei as BRow,
  et as BSkeleton,
  Hi as BSkeletonIcon,
  Ri as BSkeletonTable,
  ji as BSkeletonWrapper,
  Pt as BSpinner,
  Br as BTab,
  ir as BTable,
  Et as BTableSimple,
  yr as BTabs,
  rr as BTbody,
  cr as BTd,
  fr as BTfoot,
  mr as BTh,
  gr as BThead,
  Ea as BToast,
  Ct as BToastContainer,
  ro as BToastPlugin,
  Ct as BToaster,
  pr as BTr,
  lt as BTransition,
  Tr as BootstrapVue3,
  st as BvEvent,
  Tr as default,
  jl as useBreadcrumb,
  Da as useToast,
  Wl as vBPopover,
  zt as vBToggle,
  Ql as vBTooltip,
  en as vBVisible
};
